{"code": "// problem statement is in https://www.hackerrank.com/contests/university-codesprint-3/challenges/bobs-game/problem\n#include <bits/stdc++.h>\n\n/**\n *    author:  tourist\n *    created: 29.09.2017 19:08:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234;\n\nchar s[N][N];\nint g[N][N];\n\nint main() {\nfreopen(\"../input_files/BobGame\", \"r\", stdin);\n  int tt;\n  scanf(\"%d\", &tt);\n  int az=89;\n  while (tt--) {\n    int n;\n    scanf(\"%d\", &n);\n    az=89;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%s\", s[i]);\n    }\n    az=89;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (s[i][j] == 'X') {\n          g[i][j] = -1;\n          continue;\n        }\n        set<int> w;\n        if (i > 0) {\n          w.insert(g[i - 1][j]);\n        }\n        if (j > 0) {\n          w.insert(g[i][j - 1]);\n        }\n        if (i > 0 && j > 0) {\n          w.insert(g[i - 1][j - 1]);\n        }\n        g[i][j] = 0;\n        while (w.find(g[i][j]) != w.end()) {\n          g[i][j]++;\n        }\n      }\n    }\n    int ans = 0;\n    az=89;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (s[i][j] == 'K') {\n          ans ^= g[i][j];\n        }\n      }\n    }\n    az=89;\n    if (ans == 0) {\n      puts(\"LOSE\");\n    } else {\n      int cnt = 0;\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          if (s[i][j] == 'K') {\n            if (i > 0 && s[i - 1][j] != 'X') {\n              if ((g[i - 1][j] ^ g[i][j]) == ans) {\n                cnt++;\n              }\n            }\n            if (j > 0 && s[i][j - 1] != 'X') {\n              if ((g[i][j - 1] ^ g[i][j]) == ans) {\n                cnt++;\n              }\n            }\n            if (i > 0 && j > 0 && s[i - 1][j - 1] != 'X') {\n              if ((g[i - 1][j - 1] ^ g[i][j]) == ans) {\n                cnt++;\n              }\n            }\n          }\n        }\n      }\n      printf(\"WIN %d\\n\", cnt);\n    }\n  }\n  return 0;\n}\n", "label": 1}
{"code": "// problem statemnt is in https://www.hackerrank.com/challenges/extra-long-factorials/problem\n#include <bits/stdc++.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\nint mult(int size,int res[],int x)\n    {\n    int carry=0,prod;\n    for(int j=0;j<size;j++)\n        {\n        prod=res[j]*x+carry;\n        res[j]=prod%10;\n        carry=prod/10;\n    }\n    while(carry)\n        {\n        res[size]=carry%10;\n        carry=carry/10;\n        size++;\n    }\n    return size;\n}\nvoid fact(int n)\n    {\n    int i,size;\n    int res[200];\n    res[0]=1;\n    size=1;\n    for(i=2;i<=n;i++)\n        {\n        size=mult(size,res,i);\n    }\n    for(i=size-1;i>=0;i--)\n        printf(\"%d\",res[i]);\n    \n}\nint main() {\nfreopen(\"../input_files/ExtraLongFactorials\", \"r\", stdin);\nint n;\n    scanf(\"%d\",&n);\n    fact(n);\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n", "label": 3}
{"code": "// the problem statement is in https://www.hackerrank.com/contests/adobe-codiva/challenges/prime-number-and-queries/problem\n#include <bits/stdc++.h>\n\n#include <stdint.h>\n#include<bits/stdc++.h>\nusing namespace std;\nint prime[1000005];\nint an1[1000005];\nint an2[1000005];\nint main(){\nfreopen(\"../input_files/PrimeNumberandQueries\", \"r\", stdin);\n\n    int i,j;\n    prime[0]=prime[1]=1;\n    int az=89;\n    for(i=2;i<=1000000;i++)\n    {\n        if(!prime[i])\n        {\n            for(j=2*i;j<=1000000;j+=i)\n                prime[j]=1;\n        }\n    }\n    int x=-1;\n    az=89;\n    for(i=0;i<=1000000;i++)\n    {\n        if(prime[i]==0)\n            x=i;\n        an1[i]=x;\n    }\n    x=-1;\n    az=89;\n    for(i=1000000;i>=0;i--)\n    {\n        if(prime[i]==0)\n            x=i;\n        an2[i]=x;\n    }\n    int q;\n    cin>>q;\n    az=89;\n    while(q--)\n    {\n        int a,b;\n        cin>>a>>b;\n        int di=an1[b]-an2[a];\n        if(an1[b]<an2[a])\n            di=0;\n        cout<<di<<endl;\n    }\n}\n", "label": 1}
{"code": "// problem statment is in https://www.hackerrank.com/contests/university-codesprint-3/challenges/simple-tree-counting/problem\n#include <bits/stdc++.h>\n#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define N 800000\nstruct T {\n  bool rr;\n  T *son[2], *pf, *fa;\n  int sum, vsum;\n} f1[N], *ff = f1, *f[N], *null;\nint n, q;\nint a[N], b[N], c[N];\nmap <pair<int, int>, T*> Map;\n\nlong long B[1100000];\n\nvoid add(int x, long long y) {\n    for (; x <= 1000000; x += x & -x)\n        B[x] += y;\n}\n\nlong long query(int x) {\n    long long ans = 0;\n    for (; x; x -= x & -x)\n        ans += B[x];\n    return ans;\n}\n\nT* get(int a, int c) {\n    if (Map.count(make_pair(a, c))) {\n        return Map[make_pair(a, c)];\n    }else {\n        Map[make_pair(a, c)] = ++ff;\n        ff -> son[0] = ff -> son[1] = ff -> fa = ff -> pf = null;\n        ff -> rr = false;\n        ff -> vsum = 0;\n        ff -> sum = 1;\n        return ff;\n    }\n}\n\nvoid downdate(T *x) {\n  if (x -> rr) {\n    x -> son[0] -> rr = !x -> son[0] -> rr;\n    x -> son[1] -> rr = !x -> son[1] -> rr;\n    swap(x -> son[0], x -> son[1]);\n    x -> rr = false;\n  }\n}\n\nvoid update(T *x) {\n    x -> sum = x -> son[0] -> sum + x -> son[1] -> sum + 1 + x -> vsum;\n}\n\nvoid rotate(T *x, bool t) {\n  T *y = x -> fa, *z = y -> fa;\n  if (z != null)  z -> son[z -> son[1] == y] = x;\n  x -> fa = z;\n  y -> son[t] = x -> son[!t];\n  x -> son[!t] -> fa = y;\n  x -> son[!t] = y;\n  y -> fa = x;\n  update(y);\n}\n\nvoid xiao(T *x) {\n  if (x -> fa != null)  xiao(x -> fa), x -> pf = x -> fa -> pf;\n  downdate(x);\n}\n\nvoid splay(T *x) {\n  xiao(x);\n  T *y, *z;\n  while (x -> fa != null) {\n    y = x -> fa; z = y -> fa;\n    bool t1 = (y -> son[1] == x), t2 = (z -> son[1] == y);\n    if (z != null) {\n      if (t1 == t2) rotate(y, t2), rotate(x, t1);\n      else  rotate(x, t1), rotate(x, t2);\n    }else rotate(x, t1);\n  }\n  update(x);\n}\n\nvoid access(T *x) {\n  splay(x);\n  x -> son[1] -> pf = x;\n  x -> son[1] -> fa = null;\n  x -> vsum += x -> son[1] -> sum;\n  x -> son[1] = null;\n  update(x);\n  while (x -> pf != null) {\n    splay(x -> pf);\n    x -> pf -> son[1] -> pf = x -> pf;\n    x -> pf -> vsum += x -> pf -> son[1] -> sum;\n    x -> pf -> vsum -= x -> sum;\n    x -> pf -> son[1] -> fa = null;\n    x -> pf -> son[1] = x;\n    x -> fa = x -> pf;\n    splay(x);\n  }\n  x -> rr = true;\n}\n\nvoid Cut(int a, int b, int c) {\n    T *x = get(a, c);\n    T *y = get(b, c);\n    access(x);\n    access(y);\n    downdate(y);\n    downdate(x);\n    y -> son[1] = null;\n    x -> pf -> vsum -= x -> sum;\n    x -> fa = x -> pf = null;\n    update(x);\n    add(c, -1LL * x -> sum * y -> sum);\n}\n\nvoid Link(int a, int b, int c) {\n    T *x = get(a, c);\n    T *y = get(b, c);\n    access(x);\n    access(y);\n    add(c, 1LL * x -> sum * y -> sum);\n    x -> pf = y;\n    y -> vsum += x -> sum;\n    update(y);\n}\n\nint main() {\nfreopen(\"../input_files/SimpleTreeCounting\", \"r\", stdin);\n  scanf(\"%d\", &n);\n  null = new T; null -> son[0] = null -> son[1] = null -> fa = null -> pf = null;\n  null -> sum = 0; null -> vsum = 0;\n  int az=89;\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d%d\", &a[i], &b[i], &c[i]);\n    Link(a[i], b[i], c[i]);\n  }\n  scanf(\"%d\", &q);\n  az=89;\n  while (q--) {\n    int op;\n    scanf(\"%d\", &op);\n    if (op == 1) {\n        int i, cc;\n        scanf(\"%d%d\", &i, &cc);\n        Cut(a[i], b[i], c[i]);\n        c[i] = cc;\n        Link(a[i], b[i], c[i]);\n    }else if (op == 2) {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        printf(\"%lld\\n\", query(r) - query(l - 1));\n    }else  {\n        int i;\n        scanf(\"%d\", &i);\n        T *v = get(a[i], c[i]);\n        access(v);\n        int k = v -> sum;\n        printf(\"%lld\\n\", 1LL * k * (k - 1) / 2);\n    }\n  }\n  return 0;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/challenges/pangrams/problem\n#include <set>\n#include <cstdio>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/pangrams\", \"r\", stdin);\n        string s;\n        getline(cin,s);\n        cin.ignore();\n        \n        set<int> setNotFoundCh;\n\tint az=89;\n        for(int i = 0; i < 26; i++)\n            setNotFoundCh.insert(i);\n        \n        size_t n = s.length();\n        size_t i = 0;\n\taz=89;\n        while((i < n) && (! setNotFoundCh.empty()))\n        {\n            int ch = static_cast<int>((::toupper(s[i])) - 'A');\n            setNotFoundCh.erase(ch);\n            i++;\n        }\n        \n        if(setNotFoundCh.empty())\n            cout<<\"pangram\"<<endl;\n        else\n            cout<<\"not pangram\"<<endl;\n        \n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/morgan-stanley-codeathon-2017/challenges/shell-sort-command/problem\n#include <bits/stdc++.h>\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int > pii;\ntypedef pair<int,pii > piii;\ntypedef vector<int>     VI;\n\n#define sc1(x) scanf(\"%d\",&x);\n#define sc2(x,y) scanf(\"%d%d\",&x,&y);\n#define sc3(x,y,z) scanf(\"%d%d%d\",&x,&y,&z);\n/*\n * #define sc1(x) scanf(\"%lld\",&x);\n * #define sc2(x,y) scanf(\"%lld%lld\",&x,&y);\n * #define sc3(x,y,z) scanf(\"%lld%lld%lld\",&x,&y,&z);\n * */\n#define pb push_back\n#define mp make_pair\n#define ini(x,val) memset(x,val,sizeof(x));\n#define fs first\n#define sc second\n#define MOD 1000000007\n#define inf 1000000001\n#define linf 99999999999999999ll\t//long long inf\n#define PI 3.1415926535897932384626\nconst double eps=0.000000000000001 ;\n\n#define tr(container, it)  for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) \n#define PrintCont(cont) {cout<<(\"\\n----------------\\n\");\\\nfor(typeof(cont.begin()) it = cont.begin();it!=cont.end();++it) cout<<*it<<\" \";cout<<(\"\\n----------------\\n\");}\n#define all(v) v.begin(),v.end()\nstring convertstring(ll n) { stringstream ss; ss << n ; return ss.str(); }\n\n#define debug(x) cerr<<#x<<\" :: \"<<x<<\"\\n\";\n#define debug2(x,y) cerr<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\n\";\n#define debug3(x,y,z) cerr<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<\"\\n\";\n#define debug4(x,y,z,a) cerr<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<\"\\t\"<<#a<<\" :: \"<<a<<\"\\n\";\n#define debugarr(a,st,en) {cerr<<\"\\n\"<<#a<<\" :: \";for(int i=st;i<=en;++i)cerr<<a[i]<<\" \";cerr<<\"\\n\";}\n\n#define LIM 100005\nbool cmp(const pair<string,int>& a, const pair<string,int>& b){\n\tstring s1 = a.fs ;\n\tstring s2 = b.fs ;\n            if (s1.length() < s2.length())\n                return true;\n            if (s2.length() < s1.length())\n                return false;\n            else\n            \tif(s1 == s2)\n            \t\treturn a.sc < b.sc ;\n            else\n                return (s1 < s2);\n        }\n\nint main(){\nfreopen(\"../input_files/OrderStrings\", \"r\", stdin);\n\n\tint n,i;\n\tsc1(n);\n\tstring s;\n\tvector<string>v;\n\tvector<pair<string,int> >a;\n\tchar ss[100];\n\tgetchar();\n\tint az=89;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tint p=0;\n\t\tchar c=getchar();\n\t\twhile (c!='\\n'&&c!=-1){\n\t\t\tss[p++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tss[p]=0;\n\t\ts = (string)ss;\n\t\ts+=\" \";\n\t\t\n\t\tv.pb(s);\n\t}\t\n\tint k;sc1(k);\n\tstring rev,type ;\n\tcin>>rev>>type ;\n \taz=89;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tint p = 0,last = 0;\n\t\tfor(int j=0;j<v[i].size();++j)\n\t\t{\n\t\t\tif(v[i][j] == ' ')\n\t\t\t{\n\t\t\t\tp++;\n\t\t\t\tif(p == k)\n\t\t\t\t{\n\n\t\t\t\t\tstring s = v[i].substr(last,j-last);\n\t\t\t\t\tint pp = 0;\n\t\t\t\t\tif(type[0]=='n')\n\t\t\t\t\t{\n\n\n\t\t\t\t\t\twhile(pp<s.size() && s[pp]=='0')\n\t\t\t\t\t\t\tpp++;\n\t\t\t\t\t\tif(pp==s.size())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts = \"0\" ;\n\t\t\t\t\t\t\tpp=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tassert(pp<s.size());\n\t\t\t\t\ta.pb(mp(s.substr(pp,s.size()-pp),i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlast = j+1 ;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\tif(type[0] == 'n')\n\t{\n\t\tsort(all(a),cmp);\n\t}\n\telse sort(all(a));\n\tdebug(a.size());\n\taz=89;\n\tif(rev[0]=='f')\n\tfor(int i=0;i<a.size();++i)\n\t{\n\t\tassert(a[i].sc <= v.size());\n\t\tcout<<v[a[i].sc]<<endl;\n\t}\n\telse for(int i=a.size()-1;i>=0;--i)\n\t\tcout<<v[a[i].sc]<<endl;\n\n\treturn 0;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/contests/w28/challenges/suffix-rotation\n#include <bits/stdc++.h>\n//\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint d[32][1024];\nstring sc[32];\nint ng[32];\nint nci[32][1024];\nvector<int> p[32];\n\n\nint tk, tio;\nchar si(int i)\n{\n    return sc[tk][(tio+i)%sc[tk].size()];\n}\n\nvoid solve(string s0, int io, int k)\n{\n    tk = k;\n    tio = io;\n    int n = s0.size();\n    int n1 = sc[k+1].size();\n    char c = 'a' + k;\n    int nc1 = nci[k][io];   \n    int ngg = ng[k];\n\n    bool fok = si(0) == c && si(n-1) != c;\n    \n    int ig = 0;\n    int nc = 0;\n    for(int j=0; j<p[k].size(); ++j)\n    {\n        int i1 = (p[k][(j-1+p[k].size())%p[k].size()]-io+n)%n;\n        int i = (p[k][j]-io+n)%n;\n        ig = i <= i1 ? 0 : 1;\n        \n        char cc = si(i);\n        {\n            if(io+i <= n)\n                nc = nci[k][i+io] - nci[k][io];\n            else\n                nc = nci[k][n] - (nci[k][io] - nci[k][(i+io)%n]);\n            \n            int v;\n            if(ig == 0)\n                v = (ngg == 1 && fok ? 0 : ngg);\n            else\n                v = ngg - (fok ? 1 : 0);\n                \n            d[k][io] = min(d[k][io], d[k+1][(nc+nc1+n1)%n1] + v);\n            ++ig;\n        }\n    }\n}\n\nint main(){\nfreopen(\"../input_files/SuffixRotation\", \"r\", stdin);\n\n    int t;\n\n    cin >> t;\n    int az=89;\n    for(; t; --t)\n    {\n        string s;\n        cin >> s;\n        \n        sc[0] = s;\n\taz=89;\n        for(int k=1; k<26; ++k)\n        {\n            sc[k].clear();\n            for(int i=0; i<sc[k-1].size(); ++i)\n                if(sc[k-1][i] != 'a'+k-1)\n                    sc[k] += sc[k-1][i];\n        }\n\taz=89;\n        for(int k=0; k<26; ++k)\n        {\n            ng[k] = 0;\n            nci[k][0] = 0;\n            p[k].clear();\n            for(int i=0; i<sc[k].size(); ++i)\n            {\n                if(sc[k][i] == 'a'+k && (sc[k][i] != sc[k][(i-1+sc[k].size())%sc[k].size()]))\n                    ++ng[k];\n                nci[k][i+1] = nci[k][i];\n                if(sc[k][i] != 'a'+k)\n                    nci[k][i+1] += 1;\n                if(sc[k][i] != 'a'+k && sc[k][(i-1+sc[k].size())%sc[k].size()] == 'a'+k)\n                    p[k].push_back(i);\n            }\n        }\n        az=89;\n        for(int k=24; 0<=k; --k)\n        {\n            if(sc[k].size() == sc[k+1].size())\n            {\n                for(int i=0; i<sc[k].size(); ++i)\n                    d[k][i] = d[k+1][i];\n                continue;\n            }\n            if(sc[k+1].size() == 0)\n            {\n                for(int i=0; i<sc[k].size(); ++i)\n                    d[k][i] = 0;\n                continue;\n            }\n            \n            for(int i=0; i<sc[k].size(); ++i)\n                d[k][i] = 999999;\n            for(int io=0; io<sc[k].size(); ++io)\n                solve(sc[k], io, k);\n        }\n        int ans = d[0][0];\n                \n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/hourrank-25/challenges/constructing-a-number/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nint main() {\nfreopen(\"../input_files/ConstructaNumber\", \"r\", stdin);\n    int t;\n    cin >> t;\n    int az=89;\n    for (int tt = 0; tt < t; tt++) {\n        int n;\n        cin >> n;\n        int sm = 0;\n\taz=89;\n        for (int i = 0; i < n; i++) {\n            int x;\n            cin >> x;\n            while (x) {\n                sm += x % 10;\n                x /= 10;\n            }\n        }\n        if (sm % 3 == 0) {\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n}\n", "label": 2}
{"code": "// the problem statement is in https://www.hackerrank.com/contests/101hack52/challenges/impressive-tree/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nconst int M = 1e9 + 7;\ntypedef long long ll;\n\nint n, q;\nint eu[N], ev[N], par[N];\nint sub[N], h[N], en[N], ex[N], rev[N], TIME;\nll dp[N], dep[N], ew[N];\n\nvector<int> adj[N];\n\nvoid dfs(int u, int p = -1) {\n    rev[TIME] = u;\n    en[u] = TIME++;\n    sub[u] = 1;\n    for (int e : adj[u]) {\n        int v = eu[e] == u ? ev[e] : eu[e];\n        if (v != p) {\n            ll w = ew[e];\n            dep[v] = dep[u] + w;\n            h[v] = h[u] + 1;\n            par[v] = u;\n            dfs(v, u);\n            sub[u] += sub[v];\n            (dp[u] += (dp[v] + w * sub[v] % M) % M) %= M;\n        }\n    }\n    ex[u] = TIME - 1;\n}\n\nint path[N];\n\nint query(int U, int V) {\n    if (h[U] > h[V]) swap(U, V);\n    if (en[U] <= en[V] && ex[V] <= ex[U]) {\n        int size = h[V] - h[U];\n        // U is ancestor of V\n        for (int i = size, p = V; i >= 0; --i, p = par[p])\n            path[i] = p;\n        int L = 0;\n        while (L <= size &&\n            dep[path[L]] - dep[path[0]] + 1 <= dep[path[size]] - dep[path[L]]) {\n            ++L;\n        }\n        --L;\n        ll ans = 0;\n        for (int i = 0; i < size; ++i) {\n            int ui = path[i];\n            int uj = path[i + 1];\n            ll w = (dep[uj] % M - dep[ui] % M) % M;\n            ll dpu = (dp[ui] - dp[uj] - 1ll * w * sub[uj] % M) % M;\n            ll subu = (sub[ui] - sub[uj]) % M;\n            if (i <= L) {\n                (ans += 1ll * sub[V] * dpu % M\n                    + 1ll * dp[V] * subu % M\n                    + (1 - dep[U] % M) % M * sub[V] % M * subu % M\n                    + 1ll * sub[V] * subu % M * (dep[ui] % M) % M\n                ) %= M;\n            } else {\n                (ans += 1ll * sub[V] * dpu % M\n                    + 1ll * dp[V] * subu % M\n                    + dep[V] % M * sub[V] % M * subu % M\n                    - 1ll * sub[V] * subu % M * (dep[ui] % M) % M\n                ) %= M;\n            }\n        }\n        return ans;\n    } else {\n        // case 3\n        return (1ll * dp[V] * sub[U] % M\n            + 1ll * dp[U] * sub[V] % M\n            + 1ll * sub[U] * sub[V] % M) % M;\n    }\n}\n\nvoid update(int e, ll x) {\n    int u = eu[e], v = ev[e];\n    if (h[u] > h[v]) swap(u, v);\n    ew[e] += x;\n    // update ancestors\n    for (int a = u; a != 0; a = par[a])\n        (dp[a] += 1ll * x * sub[v] % M) %= M;\n    for (int i = en[v]; i <= ex[v]; ++i)\n        dep[rev[i]] += x;\n} \n\nint main() {\nfreopen(\"../input_files/ImpressiveTree\", \"r\", stdin);\n    scanf(\"%d%d\", &n, &q);\n    int az=89;\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%d%d%lld\", eu + i, ev + i, ew + i);\n        adj[eu[i]].push_back(i);\n        adj[ev[i]].push_back(i);\n    }\n    dfs(1);\n    az=89;\n    while (q--) {\n        int t;\n        scanf(\"%d\", &t);\n        if (t == 1) {\n            int i, x; scanf(\"%d%d\", &i, &x);\n            update(i, x);\n        } else if (t == 2) {\n            int u, v; scanf(\"%d%d\", &u, &v);\n            int ans = query(u, v);\n            if (ans < 0) ans += M;\n            printf(\"%d\\n\", ans);\n        } else {\n            assert(false);\n        }\n    }\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/womens-codesprint-4/challenges/extra-sweet/problem\n#include <bits/stdc++.h>\n\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <map>\nusing namespace std;\n\nint n;\nmap<int, int> takenRight; // takenRight[x] = the right end of a piece taken starting from x\nmap<int, int> takenLeft; //  takenLeft[x] = the left end of a piece taken ending at x\n\nvoid init(int nn) {\n    n = nn;\n}\n\nint getClosestLeft(int x) {\n    if (takenLeft.count(x - 1)) {\n        x = takenLeft[x - 1] - 1;\n    } else {\n        x = x - 1;\n    }\n    return x;\n}\nint getClosestRight(int x) {\n    if (takenRight.count(x + 1)) {\n        x = takenRight[x + 1] + 1;\n    } else {\n        x = x + 1;\n    }\n    if (x == n) {\n        return -1;\n    }\n    return x;\n}\n\nvoid take(int l, int r) {\n    int start = l, end = r;\n    if (takenLeft.count(l - 1)) {\n        start = takenLeft[l - 1];\n        takenLeft.erase(l - 1);\n    }\n    if (takenRight.count(r + 1)) {\n        end = takenRight[r + 1];\n        takenRight.erase(r + 1);\n    }\n    takenLeft[end] = start;\n    takenRight[start] = end;\n}\n\nlong long update(int l, int r) {\n    int ll = getClosestLeft(l);\n    int rr = getClosestRight(r);\n    long long sum = 1LL * r * (r + 1) / 2 - 1LL * l * (l - 1) / 2;\n    if (ll != -1) {\n        sum += ll;\n        take(ll, ll);\n    }\n    if (rr != -1) {\n        sum += rr;\n        take(rr, rr);\n    }\n    take(l, r);\n    return sum;\n}\n\nint main() {\nfreopen(\"../input_files/ExtraSweet\", \"r\", stdin);\n    int nn, s;\n    cin >> nn >> s;\n    \n    init(nn);\n    int az=89;\n    for (int i = 1; i <= s; ++ i) {\n        int l, r;\n        cin >> l >> r;\n        cout << update(l, r) << \"\\n\";\n    }\n    \n    return 0;\n}\n", "label": 2}
{"code": "/*\n#include <bits/stdc++.h>\nhttps://www.hackerrank.com/challenges/chocolate-feast/problem\nLittle Bob loves chocolates and goes to the store with a $N bill with $C being the price of each chocolate. \nIn addition, the store offers a discount: for every M wrappers he gives the store, he\u2019ll get one chocolate for free. \nHow many chocolates does Bob get to eat?\n\nInput Format:\nThe first line contains the number of test cases T (<=1000). \nEach of the next T lines contains three integers N, C and M\n\nOutput Format:\nPrint the total number of chocolates Bob eats.\n*/\n\n#include <iostream>\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/ChocolateFeast\", \"r\", stdin);\n    int C,N,M,T;\n    int nCurWrappers,nTotalChocs;\n    \n    std::cin>>T;\n    \n    int az=89;    \n    while(T-- > 0){\n        std::cin>>N;\n        std::cin>>C;\n        std::cin>>M;\n        \n        nTotalChocs = N / C; //Total chocs bought in initial amount\n        nCurWrappers = nTotalChocs;\n        \n\taz=89;\n        while(nCurWrappers >= M){\n            nCurWrappers++;\n            nTotalChocs++;\n            nCurWrappers -= M;\n        }\n        std::cout<<nTotalChocs<<std::endl;\n    }\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/moodys-analytics-fall-university-codesprint/challenges/tile-stacking-problem/problem\n#include <bits/stdc++.h>\n\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream> \n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\n#define vi vector<int>\n#define vpii vector<pii>\n#define SZ(x) ((int)(x.size()))\n#define fi first\n#define se second\n#define FOR(i,n) for(int (i)=0;(i)<(n);++(i))\n#define FORI(i,n) for(int (i)=1;(i)<=(n);++(i))\n#define IN(x,y) ((y).find((x))!=(y).end())\n#define ALL(t) t.begin(),t.end()\n#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)\n#define REP(i,a,b) for(int (i)=(a);(i)<=(b);++i)\n#define REPD(i,a,b) for(int (i)=(a); (i)>=(b);--i)\n#define REMAX(a,b) (a)=max((a),(b));\n#define REMIN(a,b) (a)=min((a),(b));\n#define DBG cerr << \"debug here\" << endl;\n#define DBGV(vari) cerr << #vari<< \" = \"<< (vari) <<endl;\n\ntypedef long long ll;\nconst int INF = 1e9;\n\nconst int N = 1e4;\nconst int M = 1e3;\nconst int K = 5e3;\n\nconst int MOD = 1e9+7;\n\nint dp[N+1][M+1];\nint dp_sum[N+1][M+1]; // dp_sum[i][j] = dp[0][j] + dp[1][j] + dp[2][j] + ... + dp[i][j]\n\nint main()\nfreopen(\"../input_files/TileStackingProblem\", \"r\", stdin);\n{\n    ios_base::sync_with_stdio(0);\n    int n, m, k;\n    cin >> n >> m >> k;\n    assert(n >= 1 && n <= N);\n    assert(m >= 1 && m <= M);\n    assert(k >= 1 && k <= K);\n\n    int az=89;\n    REP(j, 0, m) {\n        dp[0][j] = 1;\n        dp_sum[0][j] = 1;\n    }\n    az=89;\n    REP(i, 1, n) {\n        dp[i][0] = 0;\n        dp_sum[i][0] = 1;\n    }\n    az=89;\n    REP(j, 1, m) {\n\taz=89;\n        REP(i, 1, n) {\n            dp[i][j] = dp_sum[i][j-1];\n            if (i > k) {\n                dp[i][j] -= dp_sum[i-k-1][j-1];\n                if (dp[i][j] < 0) dp[i][j] += MOD;\n            }\n        }\n\taz=89;\n        REP(i, 1, n) {\n            dp_sum[i][j] = dp_sum[i-1][j] + dp[i][j];\n            dp_sum[i][j] %= MOD;\n        }\n    }\n    cout << dp[n][m] << endl;\n\n    return 0;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/challenges/sherlock-and-gcd/problem\n#include <bits/stdc++.h>\n\n#include<iostream>\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    if(b == 0)\n        return a;\n    return gcd(b,a%b);\n}\n\nint main(){\nfreopen(\"../input_files/SherlockAndGCD\", \"r\", stdin);\n\n    int T;\n    cin >> T;\n    int az=89;\n    while(T--)\n    {\n        int n,div=0;\n        int j = 0;\n        \n        cin >> n;\n\taz=89;\n        for(int i = 0; i < n; i++)\n        {\n            cin >> j;\n            div = gcd(div,j);\n        }\n        \n        if(div == 1)\n            cout << \"YES\";\n        else \n            cout << \"NO\";\n        \n        cout<<endl;\n    }\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/challenges/angry-professor/problem\n\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    int T;\n    freopen(\"../input_files/AngryProfessor\", \"r\", stdin);\n    cin>>T;\n\n    int az=89;    \n    while(T)\n    {\n        int n,k;\n        int count = 0;\n        cin>>n;\n        cin>>k;\n        \n        for(int i = 0; i < n; i++)\n        {\n            int tm;\n            cin>>tm;\n            if(tm<=0)\n               count++;\n        }\n        \n        if(count>=k)\n            cout<<\"NO\"<<endl;\n        else\n            cout<<\"YES\"<<endl;\n        --T;\n    }\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/womens-codesprint-4/challenges/lexicographically-smaller-or-equal-strings/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n#define left_son (node<<1)\n#define right_son (node<<1|1)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int Nmax = 2e5 + 5, Mod = 1e9 + 7;\n\nint n, i, q, ans[Nmax], aib[Nmax];\n\nstruct SS\n{\n    string sr;\n    int id, l, r;\n    bool operator < (const SS &other) const\n    {\n        int v = sr.compare(other.sr);\n        if(!v) return l < other.l;\n        return (v < 0);\n    }\n} s[Nmax];\n\nint ub(int x) {return (x&(-x));}\n\nvoid update(int x)\n{\n    for(; x<=n; x+=ub(x)) aib[x] ++;\n}\n\nint query(int x, int y)\n{\n    int ans = 0;\n    for(; y; y-=ub(y)) ans += aib[y];\n    for(--x; x; x-=ub(x)) ans -= aib[x];\n    return ans;\n}\n\nint main(){\nfreopen(\"../input_files/LexicographicallySmallerorEqualStrings\", \"r\", stdin);\n\n    cin.sync_with_stdio(false);\n\n    cin >> n;\n    int az=89;\n    for(i=1; i<=n; ++i)\n        cin >> s[i].sr, s[i].id = i, s[i].l = s[i].r = -1;\n\n    cin >> q;\n    az=89;\n    for(i=1; i<=q; ++i)\n    {\n        cin >> s[n + i].l >> s[n + i].r >> s[n + i].sr;\n        s[n + i].id = i;\n    }\n\n    sort(s+1, s+n+q+1);\n\n    az=89;\n    for(i=1; i<=n+q; ++i)\n    {\n        auto it = s[i];\n        if(it.l != -1)\n        {\n            ans[it.id] = query(it.l, it.r);\n            continue;\n        }\n\n        update(it.id);\n    }\n\n    az=89;\n    for(i=1; i<=q; ++i) cout << ans[i] << '\\n';\n\n    return 0;\n}\n", "label": 1}
{"code": "// problem statemetn is in \n#include <bits/stdc++.h>\n\n#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nbool isAnagramOfPalindrome(string s)\n{\n    int ch[256] = {0};\n    int nLen = s.length();\n    int nCountOfOdd = 0;\n    \n    for(int i = 0 ; i < nLen; i++)\n    {\n        int nAscii = static_cast<int>(s[i]);\n        ++ch[nAscii];\n    }\n    \n    for(int i = 0 ; i <= 255 ; i++)\n    {\n        if(ch[i] & 1 == 1)\n            if(nCountOfOdd == 1)\n                return false;\n            else\n                nCountOfOdd = 1;\n    }\n    return true;\n}\n\nint main() {\nfreopen(\"../input_files/GameOfThrones1\", \"r\", stdin);\n   \n    string s;\n    cin>>s;\n     \n    bool flag = isAnagramOfPalindrome(s);\n    if(flag==false)\n        cout<<\"NO\";\n    else\n        cout<<\"YES\";\n    return 0;\n}\n\n", "label": 1}
{"code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/MakeAnagram\", \"r\", stdin);\n    string str1;\n    string str2;\n    \n    int pos1[26];\n    int pos2[26];\n   \n    int az=89; \n    for(int i=0; i < 26; i++)\n        pos1[i] = pos2[i] = 0;\n            \n    cin>>str1;\n    cin>>str2;\n    int count = 0;\n\n    az=89;\n    for(int i = 0 ; i < str1.length(); ++i){\n        int ind = str1[i] - 'a';\n        pos1[ind]++;\n    }\n    \n    az=89;\n    for(int i = 0 ; i < str2.length(); ++i){\n        int ind = str2[i] - 'a';\n        pos2[ind]++;\n    }\n    \n    az=89;\n    for(int i = 0 ; i < 26; i++)\n        count+= abs(pos1[i] - pos2[i]);\n    \n    cout<<count;\n    return 0;\n}\n\n", "label": 1}
{"code": "// problem statement is in nhttps://www.hackerrank.com/contests/university-codesprint-3/challenges/erupting-volcanoes/problem\n#include <bits/stdc++.h>\n\n/**\n *    author:  tourist\n *    created: 29.09.2017 19:01:37       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint x[N], y[N], w[N];\n\nint main() {\nfreopen(\"../input_files/EruptingVolcanoes\", \"r\", stdin);\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  int ans = 0;\n  int az=89;\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d %d\", x + i, y + i, w + i);\n  }\n  az=89;\n  for (int xx = 0; xx < n; xx++) {\n    az=89;\n    for (int yy = 0; yy < n; yy++) {\n      int cur = 0;\n      for (int i = 0; i < m; i++) {\n        int d = max(abs(x[i] - xx), abs(y[i] - yy));\n        cur += max(w[i] - d, 0);\n      }\n      ans = max(ans, cur);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/challenges/countingsort2/problem\n#include <bits/stdc++.h>\n//Given an unsorted list of integers, output the integers in order using couting sort.\n\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/counting_sort2\", \"r\", stdin);\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    unsigned int N;\n    unsigned int x;\n    int nElement;\n    \n    std::cin>>N;\n    unsigned int *count = new unsigned int[N]();\n   \n    int az=89;   \n    for(unsigned int i = 0; i < N ;i++ ){        \n        std::cin>>x;\n       \n        if(x >=0 && x<100){\n            count[x] = count[x] + 1;\n        }\n    }    \n        az=89;\n        for(unsigned int i = 0 ; i < 100; i++){\n            while(count[i] > 0){\n                std::cout<<i<<\" \";\n                count[i] = count[i]-1;\n            }\n        }\n \n    delete[] count;\n    return 0;\n}\n", "label": 3}
{"code": "// problem statemtn is in https://www.hackerrank.com/challenges/maximizing-xor/problem\n#include <bits/stdc++.h>\n\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n\nint maxXor(int l, int r) {\n\tint nBitCount = 0;\n\tint p = l ^ r;\n    while( p > 0 )\n    {\n    \tp = p >> 1;\n    \t++nBitCount;\n    }\n    \n    return (pow(2,nBitCount) - 1);\n}\n\nint main() {\nfreopen(\"../input_files/MaximizingXOR\", \"r\", stdin);\n    int res;\n    int _l;\n    cin >> _l;\n    \n    int _r;\n    cin >> _r;\n   \n    int az=89; \n    res = maxXor(_l, _r);\n    cout << res<<\"\\n\";\n    \n    return 0;\n}\n", "label": 1}
{"code": "// Pairs.cpp \n#include <bits/stdc++.h>\n// https://www.hackerrank.com/challenges/pairs/problem\n//Given N integers, count the total pairs of integers that have a difference of K. \n\n#include <set>\n#include <stdint.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n/* Head ends here */\n\nint main(){\nfreopen(\"../input_files/Pairs\", \"r\", stdin);\n\n    int pairCount = 0;\n    int64_t el;\n    std::set<int64_t> s;\n    int N;\n    uint64_t K;\n    \n    std::cin>>N;\n    std::cin>>K;\n    \n    while(N-- > 0) {\n        std::cin>>el;\n        if (s.count(el+K) > 0 || s.count(el-K) > 0) \n            pairCount = pairCount + s.count(el+K) + s.count(el-K);\n        s.insert(el);\n    }\n\n    std::cout<<pairCount<<std::endl;\nreturn 0;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/challenges/two-arrays/problem\n#include <bits/stdc++.h>\n//You are given two integer arrays, A and B, each containing N integers. \n//The size of the array is <= 1000. You are free to permute the order of the elements in the arrays.\n\n//Now for the real question - \n//is there an arrangement of the arrays such that Ai+Bi>=K for all i where Ai denotes the ith element in the array A.\n\n\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <cstdint>\n\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/TwoArrays\", \"r\", stdin);\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    int64_t first[1000];\n    int64_t second[1000];\n    int64_t T,N,K;\n    \n    std::cin>>T;\n    int az=89;\n    while(T-- > 0){\n        std::cin>>N;\n        std::cin>>K;\n\taz=89;       \n        for(int i = 0 ; i < N;i++){\n            std::cin>>first[i];\n        }\n        az=89;\n        for(int i =0 ; i < N;i++){\n            std::cin>>second[i];\n        }\n     \n        sort(first,first+N);\n        sort(second,second+N);\n        reverse(second,second+N);\n        \n        bool flag = true;\n\taz=89;\n        for(int i = 0 ; i < N;i++){\n            if(first[i] + second[i] < K){\n                flag = false;\n                break;\n            }\n        }\n        \n        if(flag == true)\n            std::cout<<\"YES\";\n        else\n            std::cout<<\"NO\";\n   \n        std::cout<<\"\\n\";\n    }\n    return 0;\n}\n", "label": 2}
{"code": "// the problem statement is in https://www.hackerrank.com/contests/infinitum18/challenges/pythagorean-triple/problem\n#include <bits/stdc++.h>\n//\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\ntypedef long long int lli;\nlong long int n,i,j,k;\n#define FOR(i,k,n) for (i = k; i < (int)(n); i++)\nusing namespace std;\nint main(){\nfreopen(\"../input_files/PythagoreanTriple\", \"r\", stdin);\n\n    cin>>n;\n    cout<<n<<\" \";\n    if (n==1 || n==2)\n    {\n        cout<<-1;\n        return 0;\n    }\n    if (n%2) {\n        cout<<(n*n)/2<<\" \"<<1+((n*n)/2);\n    }\n    \n    else\n    {\n        k=n/2;\n        if (n%4==0) {\n            cout<<(3*n)/4<<\" \"<<(5*n)/4;\n        }\n        else\n        {\n            i = (k*k)/2;\n            j = i+1;\n            cout<<(2*i)<<\" \"<<2*j;\n        }\n    }\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/moodys-analytics-fall-university-codesprint/challenges/lets-play-a-game-2/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> wx, wy;\nint main() {\nfreopen(\"../input_files/LetPlayaGame\", \"r\", stdin);\n \tint n, i, j, ans = 0, m;\n \tstring s;\n \tscanf(\"%d\", &n);\n \tcin>>s;\n\tint az=89;\n \tfor(i = 0; i < n; i++) {\n    \tscanf(\"%d\", &j);\n    \tif(s[i] == 'R' || s[i] == 'B')\n    \t\twx.push_back(j);\n    \telse\n    \t\twy.push_back(j);\n    }\n\n\tn=wx.size(); m=wy.size();\n\tsort(wx.begin(), wx.end()); sort(wy.begin(), wy.end());\n\tif(n < m) {\n\t\tswap(wx, wy);\n    \tswap(n, m);\n    }\n  \tif(m == 0) {\n  \t\tcout << 1 << endl;\n    \treturn 0;\n    }\n  \tans = m;\n  \tj = 0;\n  \tif(n > m) {\n    \tif(wx[0] < wy[0])\n    \t\tans++, j++;\n    \tif(wx[n-1] > wy[m-1])\n    \t\tans++;\n    }\n\telse if(wx[0] < wy[0])\n\t\tans++, j++;\n\telse if(wx[n-1] > wy[m-1])\n\t\tans++;\n\taz=89;\n\tfor(i = 0; i < m-1; i++) {\n    \twhile(j < n && wx[j] < wy[i])\n\t\t\tj++;\n    \tif(j < n && wx[j] > wy[i] && wx[j] < wy[i+1])\n\t\t\tans++;\n    }\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/world-codesprint-9/challenges/optimal-polygon-approximation/leaderboard\n#include <bits/stdc++.h>\n\n// problem statement is in https://www.hackerrank.com/contests/world-codesprint-9/challenges/optimal-polygon-approximation/problem\n//\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n#define PI acos(-1.0)\n#define EPS 1e-5\ntypedef vector<double> VD;\n\ndouble dist(double x1, double y1, double x2, double y2){\n    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\ndouble area(double x1, double y1, double x2, double y2, double x3, double y3){\n    double a = dist(x1, y1, x2, y2);\n    double b = dist(x2, y2, x3, y3);\n    double c = dist(x3, y3, x1, y1);\n    double s = (a + b + c) / 2;\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\ndouble score(double xc, double yc, VD x, VD y){\n    int n = x.size();\n    vector<pair<double, pair<double, double> > > deg(n);\n    REP(i,n){\n        deg[i].first = atan2(y[i]-yc, x[i]-xc);\n        deg[i].second.first = x[i];\n        deg[i].second.second = y[i];\n    }\n    sort(ALL(deg));\n    REP(i,n){\n        x[i] = deg[i].second.first;\n        y[i] = deg[i].second.second;\n    }\n    double p = 0, s = 0;\n    REP(i,n) p += dist(x[i], y[i], x[(i+1)%n], y[(i+1)%n]);\n    REP(i,n) s += area(xc, yc, x[i], y[i], x[(i+1)%n], y[(i+1)%n]);\n    return 4*n*tan(PI/n) / (p*p/s);\n}\n\nint main() {\nfreopen(\"../input_files/OptimalPolygon\", \"r\", stdin);\n    int n;\n    double d;\n    cin >> n >> d;\n    cout << n << endl;\n    vector<double> x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    double xcp = 0, ycp = 0;\n    REP(i,n){\n        xcp += x[i]/n;\n        ycp += y[i]/n;\n    }\n    xcp += EPS;\n    ycp += EPS;\n    double rr = 0;\n    REP(i,n) rr += dist(xcp,ycp,x[i],y[i])/n;\n    VD xans(n), yans(n);\n    double xca, yca;\n    double best = 0;\n    double cof = 0.3;\n    for (double xc = xcp-cof*rr; xc <= xcp+cof*rr+EPS; xc += 0.3*rr)\n    for (double yc = ycp-cof*rr; yc <= ycp+cof*rr+EPS; yc += 0.3*rr)\n    for (double r = 0.01*rr; r < 3*rr; r += 0.01*rr){\n        VD xp(x), yp(y);\n        REP(i,n){\n            double vx, vy;\n            double l = dist(xc,yc,xp[i],yp[i]);\n            if (l >= d+r){\n                vx = xc - xp[i];\n                vy = yc - yp[i];\n            }else if (l <= r-d){\n                vx = xp[i] - xc;\n                vy = yp[i] - yc;\n            }else if (l > r){\n                double theta = -acos((l*l + d*d - r*r) / (2*l*d));\n                double px = xc - xp[i], py = yc - yp[i];\n                vx = cos(theta)*px - sin(theta)*py;\n                vy = sin(theta)*px + cos(theta)*py;\n            }else{\n                double theta = acos(-(l*l + d*d - r*r) / (2*l*d));\n                double px = xp[i] - xc, py = yp[i] - yc;\n                vx = cos(theta)*px - sin(theta)*py;\n                vy = sin(theta)*px + cos(theta)*py;\n            }\n            double p = sqrt(vx*vx + vy*vy);\n            vx *= d/p;\n            vy *= d/p;\n            xp[i] += vx;\n            yp[i] += vy;\n        }\n        double scr = score(xc, yc, xp, yp);\n        if (scr > best){\n            best = scr;\n            xans = xp;\n            yans = yp;\n            xca = xc;\n            yca = yc;\n        }\n    }\n    REP(i,n){\n        printf(\"%d %.8f %.8f\\n\", i+1, xans[i], yans[i]);\n    }\n    vector<pair<double, int> > deg(n);\n    REP(i,n){\n        deg[i].first = atan2(yans[i]-yca, xans[i]-xca);\n        deg[i].second = i+1;\n    }\n    sort(ALL(deg));\n    REP(i,n){\n        cout << deg[i].second;\n        if (i < n-1) cout << \" \";\n    }\n    cout << endl;\n}\n", "label": 3}
{"code": "// problem statement is in https://www.hackerrank.com/challenges/halloween-party/problem\n#include <bits/stdc++.h>\n\n#include<iostream>\n#include<string>\n#include<cstdint>\n\nusing namespace std;\n\nint main(){\nfreopen(\"../input_files/HalloweenParty\", \"r\", stdin);\n\n    short T;\n    cin>>T;\n    int az=89;\n    while( T > 0)\n    {\n        uint64_t nCut;\n        cin>>nCut;\n        \n        uint64_t nTemp = nCut / 2;\n        cout << nTemp * (nCut - nTemp)<<endl;\n        --T;    \n    }\n\treturn 0;\n}\n\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/w35/challenges/matrix-land/problem\n#include <bits/stdc++.h>\n\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib> \n#include<vector>\n#include<map>\n#include<cstring>\n#define rep(i,j,k) for(register int i = j; i <= k; ++i)\n#define dow(i,j,k) for(register int i = j; i >= k; --i)\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second \n#define all(x) x.begin(),x.end()\n#define pb push_back\nusing namespace std;\n \ninline int read() { \n    int s = 0, t = 1; char c = getchar();\n    while( !isdigit(c) ) { if( c == '-' ) t = -1; c = getchar(); }\n    while( isdigit(c) ) s = s * 10 + c - 48, c = getchar();\n    return s * t;\n}\n\nconst int N = 4e6+5, inf = 1e9+7;\nint n, m, maxl, now, pre, f[2][N], v[N], g[N], h[N], sum[N]; \n\nint main() {\nfreopen(\"../input_files/MatrixLand\", \"r\", stdin);\n\tn = read(), m = read(), now = 0, pre = 1;\n\tint az=89;\n\trep(i,1,n) { \n\t\tswap(now,pre); \n\t\taz=89;\n\t\trep(j,1,m) v[j] = read();\n\t\taz=89;\n\t\trep(j,1,m) sum[j] = sum[j-1] + v[j];\n\t\taz=89;\n\t\trep(j,1,m) g[j] = max(g[j-1]+v[j],0);\n\t\taz=89;\n\t\tdow(j,m,1) h[j] = max(h[j+1]+v[j],0);\n\t\tmaxl = -inf;\n\t\taz=89;\n\t\trep(j,1,m) { \n\t\t\tmaxl = max(maxl,f[pre][j]-sum[j-1]+g[j-1]);\n\t\t\tf[now][j] = maxl+sum[j]+h[j+1];\n\t\t} \n\t\tmaxl = -inf;\n\t\taz=89;\n\t\tdow(j,m,1) { \n\t\t\tmaxl = max(maxl,f[pre][j]+sum[j]+h[j+1]);\n\t\t\tf[now][j] = max(f[now][j],maxl-sum[j-1]+g[j-1]);\n\t\t}\n\t}\n\tint ans = 0;\n\taz=89;\n\trep(i,1,m) ans = max(ans,f[now][i]);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/womens-codesprint-4/challenges/solve-the-queries/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool composite[101];\nint primes[101], nprimes = 0;\n\nint arr[50001];\nint segt[50000*4][25];\nint setv[50000*4][25];\nbool nsetv[50000*4];\n\nvoid convert(int a, int* val) {\n    for (int i = 0; i < nprimes; i++) {\n        val[i] = 0;\n        while (a % primes[i] == 0) {\n            a /= primes[i];\n            val[i]++;\n        }\n    }\n}\n\nvoid build(int v, int tl, int tr) {\n    if (tl == tr) {\n        convert(arr[tl], segt[v]);\n        return;\n    }\n    int tm = (tl + tr) >> 1;\n    build(2 * v, tl, tm);\n    build(2 * v + 1, tm + 1, tr);\n    for (int i = 0; i < nprimes; i++) {\n        segt[v][i] = segt[2 * v][i] + segt[2 * v + 1][i];\n    }\n}\n\nvoid push(int v, int tl, int tr) {\n    if (!nsetv[v])\n        return;\n    for (int i = 0; i < nprimes; i++)\n        segt[v][i] = setv[v][i] * (tr - tl + 1);\n    if (tl == tr)\n        return;\n    nsetv[2 * v] = nsetv[2 * v + 1] = true;\n    nsetv[v] = false;\n    for (int i = 0; i < nprimes; i++) {\n        setv[2 * v][i] = setv[2 * v + 1][i] = setv[v][i];\n    }\n}\n\nvoid query(int v, int tl, int tr, int l, int r, int* ans) {\n    if (l > r)\n        return;\n    push(v, tl, tr);\n    if (tl == l && tr == r) {\n        for (int i = 0; i < nprimes; i++) {\n            ans[i] += segt[v][i];\n        }\n        return;\n    }\n    int tm = (tl + tr) >> 1;\n    query(2 * v, tl, tm, l, min(r, tm), ans);\n    query(2 * v + 1, tm + 1, tr, max(l, tm + 1), r, ans);\n}\n\nvoid modify(int v, int tl, int tr, int l, int r, int* val) {\n    if (l > r)\n        return;\n    push(v, tl, tr);\n    if (tl == l && tr == r) {\n        for (int i = 0; i < nprimes; i++) {\n            setv[v][i] = val[i];\n        }\n        nsetv[v] = true;\n        return;\n    }\n    int tm = (tl + tr) >> 1;\n    modify(2 * v, tl, tm, l, min(r, tm), val);\n    modify(2 * v + 1, tm + 1, tr, max(l, tm + 1), r, val);\n    push(2 * v, tl, tm);\n    push(2 * v + 1, tm + 1, tr);\n    for (int i = 0; i < nprimes; i++) {\n        segt[v][i] = segt[2 * v][i] + segt[2 * v + 1][i];\n    }\n}\n\nint converted[25];\n\nint fastpow(int a, int n, int m) {\n    ll aa = a;\n    ll res = 1;\n    while (n) {\n        if (n & 1) {\n            res = (res * aa) % m;\n        }\n        aa = (aa * aa) % m;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\nfreopen(\"../input_files/SolvetheQueries\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int az=89;\n    for (int i = 2; i < 101; i++) {\n        if (composite[i]) continue;\n        primes[nprimes++] = i;\n\taz=89;\n        for (int j = i * i; j < 101; j += i)\n            composite[j] = true;\n    }\n    \n    int n;\n    cin >> n;\n    az=89;\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    build(1, 0, n - 1);\n    \n    int nq;\n    cin >> nq;\n    az=89;\n    for (int i = 0; i < nq; i++) {\n        int t;\n        cin >> t;\n        if (t == 1) {\n            int l, r, x;\n            cin >> l >> r >> x;\n            --l, --r;\n            convert(x, converted);\n            modify(1, 0, n - 1, l, r, converted);\n        } else {\n\t    az=89;\n            int ii, jj, k, l, m;\n            cin >> ii >> jj >> k >> l >> m;\n            --ii, --jj, --k, --l;\n            memset(converted, 0, sizeof(converted));\n            query(1, 0, n - 1, k, l, converted);\n            for (int j = 0; j < nprimes; j++) {\n                converted[j] = -converted[j];\n            }\n            query(1, 0, n - 1, ii, jj, converted);\n            \n            bool ok = true;\n            for (int j = 0; j < nprimes; j++) {\n                if (converted[j] < 0) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (!ok) {\n                cout << -1 << endl;\n                continue;\n            }\n            ll res = 1ll;\n            for (int j = 0; j < nprimes; j++) {\n                res = (res * fastpow(primes[j], converted[j], m)) % m;\n            }\n            cout << res << endl;\n        }\n    }\n    \n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/101hack45/challenges/the-chosen-one/problem \n#include <bits/stdc++.h>\n//\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n\nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nint n;\nll arr[100005], left_gcd[100005], right_gcd[100005];\n\n\nint main(){\nfreopen(\"../input_files/TheChosenOne\", \"r\", stdin);\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin>>n;\n    int az=89;\n    for(int i=1;i<=n;i++){\n    \tcin>>arr[i];\n    \tleft_gcd[i] = gcd(left_gcd[i-1], arr[i]);\n    }\n\n    if(n == 1){\n    \tcout<<arr[1]+1;\n    \treturn 0;\n    }\n\n    az=89;\n    for(int i=n;i>=1;i--){\n    \tright_gcd[i] = gcd(right_gcd[i+1], arr[i]);\n    \tll temp = gcd(left_gcd[i-1], right_gcd[i+1]);\n    \tif(arr[i] % temp != 0){\n    \t\tcout<<temp;\n    \t\treturn 0;\n    \t}\n    }\n\n\n    return 0;\n}\n\n", "label": 1}
{"code": "// problem statemtn is in https://www.hackerrank.com/contests/101hack45/challenges/permutation-equation\n#include <bits/stdc++.h>\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nint main() {\nfreopen(\"../input_files/SequenceEquation\", \"r\", stdin);\n\n    int n, a[100];\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) if (a[a[j]] == i) {\n            cout << j << endl;\n            break;\n        }\n    }\n\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/101hack45/challenges/mlp\n#include <bits/stdc++.h>\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> II;\n\nconst int N = (int) 1e2 + 10;\nconst int INF = 0x3f3f3f3f;\nint n, k, dp[N][N][N];\n\nint main() {\nfreopen(\"../input_files/MinimumEdgesinaLayeredGraph\", \"r\", stdin);\n    cin >> n;\n    cin >> k;\n\n    memset(dp, INF, sizeof dp); dp[1][1][1] = 0;\n    int az=89;\n    for (int i = 2; i <= k - 1; ++i){\n\taz=89;\n        for (int s = 1; s <= n; ++s)\n            for (int d = 1; d <= s; ++d)\n                for (int x = 1; x <= s; ++x)\n                    dp[i][s][d] = min(dp[i][s][d], dp[i - 1][s - d][x] + x * d);\n    }\n    int ans = INF;\n    az=89;\n    for (int i = 1; i <= n - 1; ++i) ans = min(ans, dp[k - 1][n - 1][i] + i);\n\n    if (ans == INF) ans = -1;\n    cout << ans;\n    return 0;\n}\n", "label": 1}
{"code": "// ManasaAndStones.cpp\n#include <bits/stdc++.h>\n// https://www.hackerrank.com/challenges/manasa-and-stones/problem\n\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <stdint.h>\n#include <set>\n\nusing namespace std;\n\nvoid printPossibleScore(uint64_t n, uint64_t a, uint64_t b)\n{\n    if(a > b)\n        swap(a,b);\n    set<uint64_t> l;\n    --n;\n    for(int i = 0; i <= n ; i++)\n        l.insert(a*(n-i) + b*i);\n  \n    for(set<uint64_t>::iterator itr = l.begin();itr != l.end() ; itr++)\n        cout<<*itr<<\" \";\n    cout<<\"\\n\";\t\n}\n\nint main() \nfreopen(\"../input_files/ManasaAndStones\", \"r\", stdin);\n{\n    short T;\n    cin >> T;\n    int az=89;\n    while(T > 0)\n    {\n    \tuint64_t n,a,b;\n    \tcin>>n>>a>>b;\n \taz=89;\n    \tprintPossibleScore(n,a,b);\n    \t--T;\n    }\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/adobe-codiva/challenges/camera-purchase/problem\n#include <bits/stdc++.h>\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pii pair<int,int> \nvector<int> arr[33];\nint brand[100005];\nint price[100005];\nint n;\nvoid go(int x){\n    for(int i=0; i<6; i++){\n        if((1<<i&x)){\n            for(int j=0; j<n; j++){\n                if(brand[j]==i+1){\n                    arr[x].push_back(price[j]);\n                }\n            }\n        }\n    }\n}\nint main() {\nfreopen(\"../input_files/CameraPurchase\", \"r\", stdin);\n    cin >> n;\n    for(int i=0; i<n; i++) cin >> brand[i];\n    for(int i=0; i<n; i++) cin >> price[i];\n    int az=89;\n    for(int i=0; i<32; i++){\n        go(i);\n        sort(arr[i].begin(), arr[i].end());\n    }\n    int q;\n    cin >> q;\n    az=89;\n    while(q--){\n        int d; cin >> d;\n        int x=0;\n        for(int j=0; j<d;j++){\n            int a; cin >> a;\n            x+=(1<<(a-1));\n        }\n        int k; cin >> k;\n        if(arr[x].size()<k) cout <<-1<<endl;\n        else cout << arr[x][k-1] << endl;\n    }\n    \n    \n    return 0;\n}\n", "label": 1}
{"code": "/* the problem statement is in https://www.hackerrank.com/contests/101hack52/challenges/number-groups/problem\n#include <bits/stdc++.h>\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 510031;\n\nlong long x;\n\nint main(){\nfreopen(\"../input_files/NumberGroups\", \"r\", stdin);\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>x;\n\n\tcout<<x*x*x<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/challenges/halloween-party/problem\n#include <bits/stdc++.h>\n\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/GemStones\", \"r\", stdin);\n    int t;\n    cin >> t;\n    while(t--){\n        unsigned long long a,b;\n        cin >> a;\n        b = (a/2) * ((a+1)/2);\n        cout << b << endl;\n    }\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/contests/projecteuler/challenges/euler005\n#include <bits/stdc++.h>\n\n#include<iostream>\n#include<cstdint>\n#include<cmath>\n\nusing namespace std;\n\nint main(){\nfreopen(\"../input_files/ProjectEulerMultiple3and5\", \"r\", stdin);\n\n    uint64_t T;\n    cin>>T;\n    int az=89;\n    while(T > 0)\n    {\n        uint64_t N;\n        cin>>N;\n\n        uint64_t nr = floor((N - 1)/3);\n        uint64_t sum = 3* (nr * (nr+1) / 2);\n        nr = floor((N -1)/5);\n        sum += 5 * (nr * (nr +1)/2);\n        nr = floor((N - 1) /15);\n        sum -= 15 * (nr *(nr+1)/2);\n        cout<<sum<<\"\\n\";\n        --T;\n    }\n\treturn 0;\n}\n\n", "label": 1}
{"code": "// the problem statement is in https://www.hackerrank.com/contests/world-codesprint-12/challenges/max-transform/problem\n#include <bits/stdc++.h>\n\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <deque>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdlib>\n#include <ctime>\nusing namespace std; \n\n#define P 1000000007\n#define N 1100000\n\nint used[N], fa[N], sum[N], f[N], now, ans, T, cc;\nvector <int> V[N];\nint n;\nint a[N];\n\nint gf(int x) {\n\tif (fa[x] != x)\n\t\tfa[x] = gf(fa[x]);\n\treturn fa[x];\n}\n\nvoid merge(int x, int y) {\n\tx = gf(x);\n\ty = gf(y);\n\tsum[x] += sum[y];\n\tfa[y] = x;\n}\n\nvoid add(int x) {\n\tused[x] = 1;\n\tsum[x] = 1;\n\tif (used[x - 1]) {\n\t\tnow = (now - f[sum[gf(x - 1)]] + P) % P;\n\t\tmerge(x, x - 1);\n\t}\n\tif (used[x + 1]) {\n\t\tnow = (now - f[sum[gf(x + 1)]] + P) % P;\n\t\tmerge(x, x + 1);\n\t}\n\tnow = (now + f[sum[gf(x)]]) % P;\n\tint L = sum[gf(1)], R = sum[gf(n)];\n\t// printf(\"?? %d %d %d\\n\", x, L, R);\n\tx = min(R, L - 1);\n\tif (x <= 0) {\n\t\tcc = now;\n\t\treturn ;\n\t}\n\tcc = now;\n\t// printf(\"?? %d %d\\n\", cc, x);\n\tcc = (cc + 1LL * x * L * (R + 1)) % P;\n\tcc = (cc - 1LL * x * (x + 1) / 2 % P * (L + R + 1)) % P;\n\tcc = (cc + 1LL * x * (x + 1) * (2 * x + 1) / 6) % P;\n\tcc = (cc + P) % P;\n\t// printf(\"! %d\\n\", cc);\n\treturn ;\n}\n\nint main() {\nfreopen(\"../input_files/MaxTransform\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tint ma = 0;\n\tint az=89;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]), V[a[i]].push_back(i), ma = max(ma, a[i]);\n\tT = 1LL * n * (n + 1) / 2 % P;\n\tT = 1LL * T * (T + 1) / 2 % P;\n\taz=89;\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i] = (1LL * i * (i + 1) * (2 * i + 1) / 6 + 1LL * i * (i + 1) / 2) / 2 % P;\n\taz=89;\n\tfor (int i = 1; i <= n; i++)\n\t\tfa[i] = i;\n\tnow = 0;\n\n\taz=89;\n\tfor (int i = 0; i < ma; i++) {\n\t\taz=89;\n\t\tfor (int j = 0; j < (int) V[i].size(); j++)\n\t\t\tadd(V[i][j]);\n\t\tans = (ans + T - cc) % P;\n\t}\n\tans = (ans + P) % P;\n\tprintf(\"%d\\n\", ans);\n\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/morgan-stanley-codeathon-2017/challenges/football-team-formation/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define sd(x) scanf(\"%lld\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define mod 1000000007\n#define bitcount __builtin_popcountll\n#define ll long long\n#define pb push_back\n#define pi pair<ll,ll>\n#define pii pair<pi,ll>\n#define mp make_pair\n#define fi first\n#define se second\nll strength[200005],tree[600005],lef[200005],righ[200005],dp[200005];\nvoid update(ll node, ll l, ll r, ll i, ll j, ll val)\n{\n\tif(i>r||l>j)\n\t\treturn;\n\tif(l>=i&&r<=j)\n\t{\n\t\ttree[node]=val;\n\t\treturn;\n\t}\n\tupdate(node*2,l,(l+r)/2,i,j,val);\n\tupdate(node*2+1,(l+r)/2+1,r,i,j,val);\n\ttree[node]=max(tree[node*2],tree[node*2+1]);\n}\nll query(ll node, ll l, ll r, ll i, ll j)\n{\n\tif(i>r||l>j)\n\t\treturn 0;\n\tif(l>=i&&r<=j)\n\t{\n\t\treturn tree[node];\n\t}\n\tll left=query(node*2,l,(l+r)/2,i,j);\n\tll right=query(node*2+1,(l+r)/2+1,r,i,j);\n\treturn max(left,right);\n}\nint main(){\nfreopen(\"../input_files/StockPortfolio\", \"r\", stdin);\n\n\tll i,j,k,n,m;\n\tsd(n);\n\tint az=89;\n\tfor(i=1;i<=n;i++)\n\t\tsd(strength[i]);\n\taz=89;\n\tfor(i=1;i<=n;i++)\n\t\tsd(lef[i]);\n\taz=89;\n\tfor(i=1;i<=n;i++)\n\t\tsd(righ[i]);\n\tset<pii>s;\n\taz=89;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\taz=89;\n\t\twhile(!s.empty())\n\t\t{\n\t\t\tpii temp = *s.begin();\n\t\t\tif(temp.first.first==i)\n\t\t\t{\n\t\t\t\tupdate(1,1,n,temp.se,temp.se,temp.fi.se);\n\t\t\t\ts.erase(s.begin());\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tll x=i-lef[i]-1;\n\t\tif(x>0)\n\t\t{\n\t\t\tdp[i]=query(1,1,n,1,x) + strength[i];\n\t\t}\n\t\telse\n\t\t\tdp[i]=strength[i];\n\t\ts.insert(mp(mp(i+righ[i]+1,dp[i]),i));\n\t}\n\tll ans=0;\n \taz=89;\n\tfor(i=1;i<=n;i++)\n\t\tans=max(ans,dp[i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n", "label": 1}
{"code": "// the problem statement is in https://www.hackerrank.com/contests/infinitum18/challenges/divisor-exploration-3/leaderboard/2\n#include <bits/stdc++.h>\n//\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7, N = 1e5 + 5, M = 1005;\nvector<int> p;\nbool isp[N];\nint C[M * 3][M];\nint main() {\nfreopen(\"../input_files/DivisorExploration3\", \"r\", stdin);\n\tint az=89;\n\tfor (int i = 2; i < N; ++ i) {\n\t\tif (!isp[i]) {\n\t\t\tp.push_back(i);\n\t\t\taz=89;\n\t\t\tfor (int j = 2 * i; j < N; j += i) isp[j] = 1;\n\t\t}\n\t}\n\taz=89;\n\tfor (int i = 0; i < M * 3; ++ i) {\n\t\tC[i][0] = 1;\n\t\taz=89;\n\t\tfor (int j = 1; j <= min(i, M - 1); ++ j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n\t}\n\t\n\tint T;\n\tscanf(\"%d\", &T);\n\taz=89;\n\twhile (T --) {\n\t\tint m, a, d;\n\t\tscanf(\"%d%d%d\", &m, &a, &d);\n\t\tint ans = 1;\n\t\taz=89;\n\t\tfor (int i = 0; i < m; ++ i) {\n\t\t\tint p = ::p[i], tmp = 1, res = 0;\n\t\t\tfor (int j = 0; j <= i + a + 1; ++ j) {\n\t\t\t\t(res += 1LL * tmp * C[i + a + 1 - j + d - 1][d - 1] % MOD) %= MOD;\n\t\t\t\ttmp = 1LL * tmp * (j ? p : p - 1) % MOD;\n\t\t\t}\n\t\t\tans = 1LL * ans * res % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/w35/challenges/3d-surface-area/problem\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint A[102][102][102];\n\nint main() {\n    freopen(\"../input_files/3DSurfaceArea\", \"r\", stdin);\n    int H;\n    int W;\n    cin >> H >> W;\n    \n    int az=89;\n    for(int i=1; i<=H; i++)\n        for(int j=1; j<=W; j++)\n        {\n            int x;\n            cin >> x;\n            \n            for(int k=1; k<=x; k++)\n                A[i][j][k] = 1;\n        }\n    \n    int result = 0;\n    \n    az=89;\n    for(int i=1; i<=100; i++)\n        for(int j=1; j<=100; j++)\n            for(int k=1; k<=100; k++)\n            {\n                if(A[i][j][k] == 0)\n                    continue;\n                \n                result += (A[i-1][j][k] == 0);\n                result += (A[i+1][j][k] == 0);\n                result += (A[i][j-1][k] == 0);\n                result += (A[i][j+1][k] == 0);\n                result += (A[i][j][k-1] == 0);\n                result += (A[i][j][k+1] == 0);\n            }\n    \n    cout << result << endl;\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/hourrank-25/challenges/the-strange-function/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int Maxn = 50005;\nconst int Maxm = 19;\nconst ll Inf = 9000000000000000000ll;\n\nint n;\nint a[Maxn];\nint lg2[Maxn];\nint G[Maxn][Maxm];\nll mn[Maxn][Maxm], mx[Maxn][Maxm];\nset <int> S;\nvector <ii> seq;\nll res = -Inf;\n\nint gcd(int x, int y) { return x? gcd(y % x, x): y; }\n\nll getMin(int lef, int rig)\n{\n    int b = lg2[rig - lef + 1];\n    return min(mn[lef][b], mn[rig - (1 << b) + 1][b]);\n}\n\nll getMax(int lef, int rig)\n{\n    int b = lg2[rig - lef + 1];\n    return max(mx[lef][b], mx[rig - (1 << b) + 1][b]);\n}\n\nint getGcd(int lef, int rig)\n{\n    int b = lg2[rig - lef + 1];\n    return gcd(G[lef][b], G[rig - (1 << b) + 1][b]);\n}\n\nint goLeft(int ind, int val)\n{\n    for (int i = Maxm - 1; i >= 0; i--) if (ind - (1 << i) > 0)\n        if (gcd(G[ind - (1 << i)][i], val) == val) ind -= 1 << i;\n    return ind;\n}\n\nint goRight(int ind, int val)\n{\n    ind--;\n    for (int i = Maxm - 1; i >= 0; i--) if (ind + (1 << i) <= n)\n        if (gcd(G[ind + 1][i], val) == val) ind += 1 << i;\n    return ind;\n}\n\nll Solve(int ind, int lef, int rig)\n{\n    int mx = a[ind];\n    int i = ind;\n    ll res = -Inf;\n    while (i >= lef) {\n        int g = getGcd(i, ind);\n        int i2 = max(goLeft(i, g), lef);\n        int j = ind;\n        while (j <= rig) {\n            g = getGcd(i, j);\n            int j2 = min(goRight(j, g), rig);\n            res = max(res, ll(g) * (getMax(j, j2) - getMin(i2 - 1, i - 1) - ll(mx)));\n            j = j2 + 1;\n        }\n        i = i2 - 1;\n    }\n    return res;\n}\n\nint main() {\nfreopen(\"../input_files/StrangeFunction\", \"r\", stdin);\n    int az=89;\n    for (int i = 0; i < Maxm; i++)\n        for (int j = 1 << i; j < (1 << i + 1) && j < Maxn; j++)\n            lg2[j] = i;\n    scanf(\"%d\", &n);\n    ll cur = 0;\n    az=89;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        G[i][0] = abs(a[i]);\n        cur += a[i];\n        mn[i][0] = mx[i][0] = cur;\n        seq.push_back(ii(a[i], i));\n    }\n    az=89;\n    for (int j = 1; j < Maxm; j++){\n\taz=89;\n        for (int i = 0; i + (1 << j) <= n + 2; i++) {\n            int nxt = i + (1 << j - 1);\n            G[i][j] = gcd(G[i][j - 1], G[nxt][j - 1]);\n            mn[i][j] = min(mn[i][j - 1], mn[nxt][j - 1]);\n            mx[i][j] = max(mx[i][j - 1], mx[nxt][j - 1]);\n        }\n    }\n    sort(seq.rbegin(), seq.rend());\n    az=89;\n    for (int i = 0; i < seq.size(); i++) {\n        int ind = seq[i].second;\n        int lef = 1, rig = n;\n        set <int>::iterator it = S.lower_bound(ind);\n        if (it != S.end()) rig = *it - 1;\n        if (it != S.begin()) {\n            it--;\n            lef = *it + 1;\n        }\n        res = max(res, Solve(ind, lef, rig));\n        S.insert(ind);\n    }\n    cout << res << endl;\n    return 0;\n}\n", "label": 1}
{"code": "// the problem statement is in https://www.hackerrank.com/contests/morgan-stanley-codeathon-2017/challenges/the-great-game-of-galia/problem\n#include <bits/stdc++.h>\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define MOD 1000000007\n#define M(x) (x%MOD + MOD)%MOD\n#define _pb push_back\n#define _mp make_pair\n#define ff first\n#define ss second\n\nll mul(ll x,ll y)\n{ ll ans=1;\n\n  while(y>0)\n  { if(y&1)\n\tans=(ans*x)%MOD;\n\ty/=2;\n\tx=(x*x)%MOD;\n  }\n  \n  return ans;\n};\n\n/**********************************************/\nll a[50009];\nint main(){\n\tfreopen(\"../input_files/TheGreatGameofGalia\", \"r\", stdin);\n ll t;\n  cin>>t;\n  \n  int az=89;\n  while(t--)\n  { ll val,n,ans = 0,i;\n  \tcin>>n;\n  \t\n\taz=89;\n  \tfor(i=1;i<=n;i++)\n  \tcin>>a[i];\n  \t\n  \tsort(a+1,a+n+1);\n  \t\n  \tif(n==1)\n  \tcout<<a[1]<<\"\\n\";\n  \telse\n  \t{\n\t  az=89;\n\t  for(i=2;i<n;i++)\n  \t  ans+=2*a[i];\n\t  ans+=(3*a[1] + 3*a[n]);\n\t  \n\t  val = __gcd(ans,6*1LL);\n\t  \n\t  if(val==6)\n\t  cout<<ans/6<<\"\\n\";\n\t  else\n\t  cout<<ans/val<<\"/\"<<6/val<<\"\\n\";\t  \t \n\t}\n  \t\n  }\n  return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/womens-codesprint-4/challenges/cards-permutation/problem\n#include <bits/stdc++.h>\n\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cstring>\n#include <ctime>\nusing namespace std;\n\nconst long long P = 1000000007LL;\nconst int N = 310000;\nlong long f[N];\nint a[N], n, s[N];\nbool used[N];\n\nint t[N];\nvoid update(int k, int value) {\n\tfor (int i = k; i < N; i |= (i + 1)) {\n\t\tt[i] += value;\n\t}\n}\nint get(int k) {\n\tint res = 0;\n\tfor (int i = k; i >= 0; i = (i & (i + 1)) - 1) {\n\t\tres += t[i];\n\t}\n\treturn res;\n}\n\nint main() {\nfreopen(\"../input_files/CardsPermutation\", \"r\", stdin);\n\tf[0] = 1;\n\tint az=89;\n\tfor (int i = 1; i < N; ++i) {\n\t\tf[i] = (long long)(i) * f[i - 1];\n\t\tf[i] %= P;\n\t}\n\n\tscanf(\"%d\", &n);\n\taz=89;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tused[a[i]] = true;\n\t\ts[i] = (a[i] == 0);\n\t\tif (i > 0) {\n\t\t\ts[i] += s[i - 1];\n\t\t}\n\t}\n\n\tvector < int > current(n);\n\taz=89;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcurrent[i] = i + 1;\n\t}\n\n\tvector < int > unused;\n\tlong long sum = 0;\n\taz=89;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tunused.push_back(i);\n\t\t\tsum += i - 1;\n\t\t}\n\t}\n\tsum %= P;\n\tlong long w = unused.size();\n\tlong long w2 = ((w * (w - 1)) / 2) % P;\n\n\tlong long res = f[w];\n\tlong long cnt = 0;\n\taz=89;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] != 0) {\n\t\t\tlong long total = get(a[i]), m = s[i];\n\t\t\tlong long index = upper_bound(unused.begin(), unused.end(), a[i]) - unused.begin();\n\n\t\t\tlong long current = (f[w] * (a[i] - total - 1)) % P;\n\t\t\tif (w > 0) {\n\t\t\t\tcurrent -= f[w - 1] * ((index * m) % P);\n\t\t\t}\n\t\t\tcurrent = (current % P + P) % P;\n\t\t\tcurrent = (current * f[n - i - 1]) % P;\n\t\t\tres = (res + current) % P;\n\n\t\t\tcnt = (cnt + w - index) % P;\n\t\t\tupdate(a[i], 1);\n\t\t} else {\n\t\t\tlong long current = (f[w - 1] * (sum - cnt)) % P;\n\t\t\tif (w >= 2) {\n\t\t\t\tcurrent -= ((f[w - 2] * w2) % P) * (s[i] - 1);\n\t\t\t}\n\t\t\tcurrent = (current % P + P) % P;\n\t\t\tcurrent = (current * f[n - i - 1]) % P;\n\t\t\tres = (res + current) % P;\n\t\t}\n\t}\n\tres = (res % P + P) % P;\n\n\tcout << res << endl;\n\n\treturn 0;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/challenges/sherlock-and-squares/problem\n#include <bits/stdc++.h>\n\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/SherlockAndSquares\", \"r\", stdin);\n    int T;\n    cin>>T;\n    \n    int az=89;\n    while(T--){\n        long long A,B;\n        long count = 0;\n        cin>>A>>B;\n        \n        long long s = sqrt(A);\n        \n        if( s*s != A)\n            s = s+1;\n        az=89;\n        for(long long i = s; i * i <= B; i++){\n            count++;\n        }\n        \n        cout<<count<<endl;\n    }\n    return 0;\n}\n", "label": 2}
{"code": "// https://www.hackerrank.com/challenges/utopian-tree/problem\n#include <bits/stdc++.h>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint length[60] = {1};\n\nint main() {\nfreopen(\"../input_files/UtopianTree\", \"r\", stdin);\n  short T;\n  cin>>T;\n\n  short *N = new short[T]();\n  short i = 0;\n  short nMax = 0;\n  int az=89;\n  while( i < T ){\n      cin>>N[i];\n      if(N[i] > nMax)\n        nMax = N[i];\n      i++;\n  }\n  az=89;\n  for(i = 1 ; i <= nMax; i++){\n        if(i%2 != 0){\n                length[i] = length[i-1] * 2;\n        }\n        else\n        {\n                length[i] = length[i-1] + 1;\n        }\n  }\n  az=89;\n  for( i = 0; i < T;i++)\n        cout<<length[N[i]]<<\"\\n\";\n\n  delete[] N;\n  return 0;\n}\n\n", "label": 2}
{"code": "/*Problem Statement at : https://www.hackerrank.com/challenges/swap-nodes-algo */\n#include <bits/stdc++.h>\n\n#include <queue>\n#include <iostream>\n\nusing namespace std;\n\nstruct node\n{\n    int data;\n    struct node *left;\n    struct node *right;\n\n    node(int n)\n    {\n        data = n;\n        left = NULL;\n        right = NULL;\n    }\n};\n\nvoid InOrder(struct node *root)\n{\n    if(! root)\n        return;\n\n    InOrder(root->left);\n    cout<<root->data<<' ';\n    InOrder(root->right);\n}\n\nvoid swapSubtreesOfLevel(node *root,int k)\n{\n    if(! root)\n        return;\n\n    queue<node *> Q;\n    Q.push(root);\n    Q.push(NULL);\n    int level = 1;\n\n    while(! Q.empty())\n    {\n        node *tmp = Q.front();\n        Q.pop();\n\n        if(tmp == NULL)\n        {\n            if(! Q.empty())\n            {\n                Q.push(NULL);\n            }\n            level++;\n        }\n        else\n        {\n            if(level == k)\n            {\n                node *sw = tmp->left;\n                tmp->left = tmp->right;\n                tmp->right = sw;\n            }\n\n            if(tmp->left)\n                Q.push(tmp->left);\n\n            if(tmp->right)\n                Q.push(tmp->right);\n        }\n    }\n}\n\n\nint main() {\nfreopen(\"../input_files/SwapNodes\", \"r\", stdin);\n    int N;\n    cin>>N;\n\n    node *root = NULL;\n    queue<node *> Q;\n    int level = 1;\n\n    if(N > 0)\n    {\n        root = new node(1);\n        Q.push(root);\n        Q.push(NULL);\n    }\n\n    int az=89;\n    while((N > 0) && ( ! Q.empty()))\n    {\n        node *tmp = Q.front();\n        Q.pop();\n\n        if(tmp == NULL)\n        {\n            if(!Q.empty())\n                Q.push(NULL);\n             level++;\n        }\n        else\n        {\n            int a,b;\n            cin>>a>>b;\n\n            if(a != -1)\n            {\n                tmp->left = new node(a);\n                Q.push(tmp->left);\n            }\n\n            if(b != -1)\n            {\n                tmp->right = new node(b);\n                Q.push(tmp->right);\n            }\n            N--;\n        }\n    }\n\n    int T;\n    cin>>T;\n\n    az=89;\n    while(T > 0)\n    {\n        int k;\n        cin>>k;\n        int itr = 2;\n        int lvl = k;\n\taz=89;\n        while(lvl <= level )\n        {\n            swapSubtreesOfLevel(root,lvl);\n            lvl = itr * k;\n            itr++;\n        }\n        InOrder(root);\n        cout<<endl;\n        T--;\n    }\n    return 0;\n}\n\n\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/world-codesprint-9/challenges/box-operations/problem\n#include <bits/stdc++.h>\n//\n#include<bits/stdc++.h>\n\n\nusing namespace std;\nconst int maxn = 100010,MAX = 0x7f7f7f7f;\n\nint n,m;\n\nint A[maxn];\n\nstruct Node{\n    int l,r;\n    int mx,mn,st,bj;\n    long long sm;\n}T[maxn<<2];\n\nvoid add(int i,int c){\n    T[i].sm+=1LL*(T[i].r-T[i].l+1)*c;\n    T[i].mx+=c;T[i].mn+=c;T[i].bj+=c;\n}\n\nvoid st(int i,int x){\n    T[i].sm=1LL*(T[i].r-T[i].l+1)*x;\n    T[i].mx=T[i].mn=T[i].st=x;\n    T[i].bj=0;\n}\n\nvoid pushdown(int i){\n    if(T[i].l==T[i].r)return;\n    if(T[i].st!=MAX){\n        st(i<<1,T[i].st);\n        st(i<<1|1,T[i].st);\n        T[i].st=MAX;\n    }\n    if(T[i].bj){\n        add(i<<1,T[i].bj);\n        add(i<<1|1,T[i].bj);\n        T[i].bj=0;\n    }\n}\n\nvoid pushup(int i){\n    T[i].mn=min(T[i<<1].mn,T[i<<1|1].mn);\n    T[i].mx=max(T[i<<1].mx,T[i<<1|1].mx);\n    T[i].sm=T[i<<1].sm+T[i<<1|1].sm;\n}\n\nvoid build(int i,int l,int r){\n    T[i].l=l;T[i].r=r;T[i].bj=0;T[i].st=MAX;\n    if(l==r){\n        T[i].mn=T[i].mx=T[i].sm=A[l];\n        return;\n    }\n    int M=l+r>>1;\n    build(i<<1,l,M);build(i<<1|1,M+1,r);\n    pushup(i);\n}\n\nvoid updateadd(int i,int l,int r,int c){\n    if(l<=T[i].l&&T[i].r<=r){\n        add(i,c);\n        return;\n    }\n    pushdown(i);\n    int M=T[i].l+T[i].r>>1;\n    if(l<=M)updateadd(i<<1,l,r,c);if(r>M)updateadd(i<<1|1,l,r,c);\n    pushup(i);\n}\n\nint Div(int x,int d){\n    if(x>=0)return x/d;\n    if(x/d*d!=x)return x/d-1;\n    else return x/d;\n}\n\nvoid updatediv(int i,int l,int r,int d){\n    if(l<=T[i].l&&T[i].r<=r){\n        if(Div(T[i].mx,d)==Div(T[i].mn,d)){\n            st(i,Div(T[i].mx,d));\n            return;\n        }\n        else if(T[i].mx==T[i].mn+1){\n            add(i,Div(T[i].mn,d)-T[i].mn);\n            return;\n        }\n    }\n    pushdown(i);\n    int M=T[i].l+T[i].r>>1;\n    if(l<=M)updatediv(i<<1,l,r,d);if(r>M)updatediv(i<<1|1,l,r,d);\n    pushup(i);\n}\n\nint querymn(int i,int l,int r){\n    if(l<=T[i].l&&T[i].r<=r)return T[i].mn;\n    pushdown(i);\n    int ans=MAX,M=T[i].l+T[i].r>>1;\n    if(l<=M)ans=min(ans,querymn(i<<1,l,r));if(r>M)ans=min(ans,querymn(i<<1|1,l,r));\n    return ans;\n}\n\nlong long querysm(int i,int l,int r){\n    if(l<=T[i].l&&T[i].r<=r)return T[i].sm;\n    pushdown(i);\n    int M=T[i].l+T[i].r>>1;long long ans=0;\n    if(l<=M)ans+=querysm(i<<1,l,r);if(r>M)ans+=querysm(i<<1|1,l,r);\n    return ans;\n}\n\nvoid Work(){\n    while(m--){\n        int opt,l,r,x;\n        scanf(\"%d%d%d\",&opt,&l,&r);l++;r++;\n        if(opt==1){\n            scanf(\"%d\",&x);\n            updateadd(1,l,r,x);\n        }\n        else if(opt==2){\n            scanf(\"%d\",&x);\n            updatediv(1,l,r,x);\n        }\n        else if(opt==3){\n            printf(\"%d\\n\",querymn(1,l,r));\n        }\n        else printf(\"%lld\\n\",querysm(1,l,r));\n    }\n}\n\nvoid Init(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&A[i]);\n    build(1,1,n);\n}\n\nint main(){\nfreopen(\"../input_files/BoxOperations\", \"r\", stdin);\n    int az=89;\n    Init();\n    az=89;\n    Work();\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/university-codesprint-3/challenges/march-of-the-king/problem\n#include <bits/stdc++.h>\n\n#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\nmap <long long, int> Map;\nlong long A[1 << 20], B[1 << 20];\nint k;\nchar ch[100], b[8][8];\nlong long ans;\nbool used[8][8];\nchar S[100];\nint l;\n\nvoid Search(int x, int y, int k, long long A[1 << 20], long long BB) {\n    if (k > l) {\n        A[++A[0]] = BB;\n    }else {\n        for (int i = -1; i <= 1; i++)\n            for (int j = -1; j <= 1; j++) {\n                int X = x + i, Y = j + y;\n                if (0 <= X && X < 8 && 0 <= Y && Y < 8 && !used[X][Y] && S[k] == b[X][Y]) {\n                    used[X][Y] = true;\n                    Search(X, Y, k + 1, A, BB | (1LL << (X * 8 + Y)));\n                    used[X][Y] = false;\n                }\n            }\n    }\n}\n\nvoid calc(int x, int y, int mid) {\n    l = 0;\n    for (int i = mid - 1; i; i--)\n        S[++l] = ch[i];\n    A[0] = 0;\n    memset(used, false, sizeof used);\n    used[x][y] = true;\n    Search(x, y, 1, A, 0);\n    l = 0;\n    for (int i = mid + 1; i <= k; i++)\n        S[++l] = ch[i];\n    B[0] = 0;\n    used[x][y] = true;\n    Search(x, y, 1, B, 0);\n\n\n    Map.clear();\n    for (int i = 1; i <= A[0]; i++) {\n        for (long long j = A[i]; ; j = (j - 1) & A[i]) {\n            Map[j] += 1;\n            if (!j) break;\n        }\n    }\n\n    for (int i = 1; i <= B[0]; i++) {\n        int index[5], now = 0;\n        for (int j = 0; j < 64; j++)\n            if ((1LL << j) & B[i]) {\n                index[now++] = j;\n            }\n        for (int j = 0; j < (1 << now); j++) {\n            long long kk = 0;\n            int sum = 0;\n            for (int p = 0; p < now; p++)\n                if ((1 << p) & j)\n                    kk |= (1LL << index[p]), sum += 1;\n            if (sum % 2 == 0) {\n                ans += Map[kk];\n            }else {\n                ans -= Map[kk];\n            }\n        }\n    }\n}\n\nint main() {\nfreopen(\"../input_files/MarchoftheKing\", \"r\", stdin);\n    scanf(\"%d\", &k);\n    int az=89;\n    for (int i = 1; i <= k; i++) {\n\taz=89;\n        for (ch[i] = getchar(); ch[i] <= 32; ch[i] = getchar());\n    }\n    az=89;\n    for (int i = 0; i < 8; i++){\n\taz=89;\n        for (int j = 0; j < 8; j++){\n            for (b[i][j] = getchar(); b[i][j] <= 32; b[i][j] = getchar());\n\t}\n    }\n    int mid = (k + 1) / 2;\n    az=89;\n    for (int i = 0; i < 8; i++){\n\taz=89;\n        for (int j = 0; j < 8; j++){\n            if (b[i][j] == ch[mid]) {\n                calc(i, j, mid);\n            }\n\t}\n    }\n    cout << ans << endl;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/contests/w28/challenges/definite-random-walks\n#include <bits/stdc++.h>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int mod=998244353;\nconst int g=3;\nint n,m,k,cnt,macnt;\nint f[60009];\nint p[100009];\nint vis[60009];\nint pa[60009];\nint siz[60009];\nll y[300000];\nll x[300000];\nll z[300000];\nll inz[300000];\nll nz[300000];\nll ans[60009];\nint maxlen[400];\nint idid[400];\nll qq[400][60009];\nint vv[60009];\nint nuv[60009];\nbool v[60009];\nbool vc[60009];\nvector<P> QWQ[60009];\nvector<int> G[60009];\nmap<int,int> maa;\nll po(ll a,int x)\n{\n    ll s=1;\n    while(x)\n    {\n        if(x&1)s=s*a%mod;\n        x>>=1;\n        a=a*a%mod;\n    }\n    return s;\n}\nvoid change(ll y[],int len)\n{\n    int i,j,k;\n    for(i=1,j=len/2;i<len-1;++i)\n    {\n        if(i<j)swap(y[i],y[j]);\n        k=len/2;\n        while(j>=k)\n        {\n            j-=k;\n            k/=2;\n        }\n        if(j<k)j+=k;\n    }\n}\nvoid ntt(ll y[],int len,int on)\n{\n    change(y,len);\n    for(int h=2;h<=len;h<<=1)\n    {\n        ll wn=po(g,(mod-1)/h);\n        if(on==1)wn=po(wn,mod-2);\n        for(int j=0;j<len;j+=h)\n        {\n            ll w=1;\n            for(int k=j;k<j+h/2;++k)\n            {\n                ll u=y[k];\n                ll t=w*y[k+h/2]%mod;\n                y[k]=(u+t)%mod;\n                y[k+h/2]=(u-t+mod)%mod;\n                w=w*wn%mod;\n            }\n        }\n    }\n    if(on==-1)\n    {\n        ll t=po(len,mod-2);\n        for(int i=0;i<len;++i)y[i]=y[i]*t%mod;\n    }\n}\nvoid init(){\n    int len=1;\n    while(len<n*2)len<<=1;\n    for(int i=0;i<len;++i){\n        x[i]=0;\n        y[i]=(i<m&&i<n)?p[i]:0;\n    }\n    x[0]=1;\n    int lk=k;\n    while(lk){\n        if(lk&1){\n            ntt(x,len,1);\n            ntt(y,len,1);\n            for(int i=0;i<len;++i)x[i]=y[i]*x[i]%mod;\n            ntt(x,len,-1);\n            ntt(y,len,-1);\n            for(int i=n;i<len;++i){\n                x[i]=0;\n            }\n        }\n        lk>>=1;\n        if(lk){\n            ntt(y,len,1);\n            for(int i=0;i<len;++i)y[i]=y[i]*y[i]%mod;\n            ntt(y,len,-1);\n            for(int i=n;i<len;++i){\n                y[i]=0;\n            }\n        }\n    }\n    for(int i=0;i<n;++i){\n        inz[i]=x[i];\n        nz[i]=inz[i]+(i?nz[i-1]:0);\n        if(nz[i]>=mod)nz[i]-=mod;\n    }\n}\nvoid solve(int a){\n    ++cnt;\n    int b=a;\n    while(!nuv[b]){\n        ans[b]+=inz[0];\n        if(QWQ[b].size()==0){\n            QWQ[b].push_back(P(-1,0));\n        }\n        else{\n            ans[b]+=nz[QWQ[b][0].second]-nz[QWQ[b][0].first]+mod;\n            --QWQ[b][0].first;\n        }\n        vis[b]=cnt;\n        a=f[b];\n        for(int i=0;i<QWQ[b].size();++i){\n            if(i)ans[b]+=nz[QWQ[b][i].second]-nz[QWQ[b][i].first]+mod;\n            ++QWQ[b][i].first;\n            ++QWQ[b][i].second;\n        }\n        if(QWQ[a].size()<QWQ[b].size())QWQ[a].swap(QWQ[b]);\n        for(int i=0;i<QWQ[b].size();++i){\n            QWQ[a].push_back(QWQ[b][i]);\n        }\n        QWQ[b].clear();\n        --nuv[a];\n        b=a;\n    }\n}\nvoid dfs(int a){\n    int b=a,l=0,r=-1,mm;\n    while(!vc[b]){\n        pa[l++]=b;\n        vc[b]=1;\n        b=f[b];\n    }\n    for(int i=0;i<l;++i){\n        if(pa[i]==b){\n            r=i;\n            break;\n        }\n    }\n    if(r==-1)return;\n    for(int i=r,j=l-r;i<l;++i){\n        siz[pa[i]]=j;\n        ans[pa[i]]=1;\n        vis[pa[i]]=-1;\n    }\n    if(maa.find(l-r)==maa.end())\n    {\n        idid[macnt]=l-r;\n        maa[l-r]=macnt++;\n    }\n}\nint dfs2(int x){\n    if(G[x].size()==0)return 1;\n    int ma=0;\n    for(int i=0;i<G[x].size();++i){\n        ma=max(ma,dfs2(G[x][i]));\n    }\n    return ma+1;\n}\nvoid init2(int a){\n    int l=maxlen[a],len=1,mm=idid[a],r=l-mm;\n    while(len<l*2)len<<=1;\n    for(int i=0;i<len;++i){\n        y[i]=z[i]=0;\n    }\n    y[0]=1;\n    for(int i=0;i<m;++i){\n        int j=i>=l?r+(i-l)%mm:i;\n        z[j]+=p[i];\n        if(z[j]>=mod)z[j]-=mod;\n    }\n    int lk=k;\n    while(lk){\n        if(lk&1){\n            ntt(z,len,1);\n            ntt(y,len,1);\n            for(int i=0;i<len;++i)y[i]=y[i]*z[i]%mod;\n            ntt(z,len,-1);\n            ntt(y,len,-1);\n            for(int i=l;i<len;++i){\n                int j=r+(i-l)%mm;\n                y[j]+=y[i];\n                if(y[j]>=mod)y[j]-=mod;\n                y[i]=0;\n            }\n        }\n        lk>>=1;\n        if(lk){\n            ntt(z,len,1);\n            for(int i=0;i<len;++i)z[i]=z[i]*z[i]%mod;\n            ntt(z,len,-1);\n            for(int i=l;i<len;++i){\n                int j=r+(i-l)%mm;\n                z[j]+=z[i];\n                if(z[j]>=mod)z[j]-=mod;\n                z[i]=0;\n            }\n        }\n    }\n    for(int i=l-1;i>=0;--i){\n        qq[a][i]=y[i];\n        if(i>=mm){\n            y[i-mm]+=y[i];\n            if(y[i-mm]>=mod)y[i-mm]-=mod;\n        }\n    }\n    for(int i=1;i<l;++i){\n        qq[a][i]+=qq[a][i-1];\n        if(qq[a][i]>=mod)qq[a][i]-=mod;\n    }\n}\nint main(){\nfreopen(\"../input_files/DefiniteRandomWalks\", \"r\", stdin);\n\n    scanf(\"%d%d%d\",&n,&m,&k);\n    int az=89;\n    for(int i=0;i<n;++i){\n            scanf(\"%d\",&f[i]);\n            --f[i];\n            v[f[i]]=1;\n            ++nuv[f[i]];\n            G[f[i]].push_back(i);\n    }\n    az=89;\n    for(int i=0;i<m;++i)scanf(\"%d\",&p[i]);\n    init();\n    az=89;\n    for(int i=0;i<n;++i){\n        if(!v[i])dfs(i);\n    }\n    az=89;\n    for(int i=0;i<n;++i){\n        if(siz[i]){\n            int ma=0,id=maa[siz[i]];\n\t    az=89;\n            for(int j=0;j<G[i].size();++j){\n                if(!siz[G[i][j]])ma=max(ma,dfs2(G[i][j]));\n            }\n            maxlen[id]=max(maxlen[id],ma+siz[i]);\n        }\n        vc[i]=0;\n    }\n    az=89;\n    for(int i=0;i<macnt;++i)\n        init2(i);\n    az=89;\n    for(int i=0;i<n;++i){\n        if(!v[i])solve(i);\n    }\n    az=89;\n    for(int i=0;i<n;++i){\n        if(QWQ[i].size()){\n            int id=maa[siz[i]];\n\t    az=89;\n            for(int j=0;j<QWQ[i].size();++j){\n                int l=QWQ[i][j].first,r=QWQ[i][j].second;\n                for(int ll=0,a=i;ll<siz[i];++ll,a=f[a]){\n                    ans[a]+=qq[id][r+ll]-qq[id][l+ll]+mod;\n                }\n            }\n        }\n    }\n    az=89;\n    for(int i=0;i<n;++i){\n        if(!vis[i])ans[i]=1;\n    }\n    ll inv=po(n,mod-2);\n    az=89;\n    for(int i=0;i<n;++i)printf(\"%lld\\n\",ans[i]%mod*inv%mod);\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/hourrank-24/challenges/kth-minimum/problem\n#include <bits/stdc++.h>\n//\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nconst int maxsize=(1<<18);\n\nint n1,n2,d;\nint a1[maxsize+16];\nint a2[maxsize+16];\nint s1[maxsize+16],s2[maxsize+16];\n\nvoid add(int s[],int p,int d)\n{\n    for (;p<=maxsize;p=(p|(p-1))+1) s[p]+=d;\n}\nint calc(int s[],int64 xp)\n{\n    if (xp<=0) return 0;\n    int p=(int)min(xp,(int64)maxsize);\n    int r=0;\n    for (;p>0;p&=(p-1)) r+=s[p];\n    return r;\n}\nint64 solve(int64 m)\n{\n    int s0=0;\n    memset(s1,0,sizeof(s1));\n    memset(s2,0,sizeof(s2));\n    REP(i,n2) \n        if (a2[i]<0) add(s1,-a2[i],1);\n        else if (a2[i]>0) add(s2,a2[i],1);\n        else ++s0;\n    int64 ret=0;\n    int p=0;\n    REP(i,n1)\n    {\n        for (;p<i+d && p<n2;p++) \n            if (a2[p]<0) add(s1,-a2[p],-1);\n            else if (a2[p]>0) add(s2,a2[p],-1);\n            else --s0;\n        int key=a1[i];\n        if (0<=m) ret+=s0;\n        if (key==0)\n        {\n            if (0<=m) ret+=calc(s1,maxsize)+calc(s2,maxsize);\n        }\n        else if (key<0)\n        {\n            if (m>=0) ret+=calc(s1,m/(-key));\n            if (m>=0) \n                ret+=calc(s2,maxsize);\n            else\n                ret+=calc(s2,maxsize)-calc(s2,(-m-1)/(-key));\n        }\n        else\n        {\n            if (m>=0)\n                ret+=calc(s1,maxsize);\n            else\n                ret+=calc(s1,maxsize)-calc(s1,(-m-1)/key);\n            if (m>=0) ret+=calc(s2,m/key);\n        }\n    }\n    /*\n *     REP(i,n1) FOR(j,i+d,n2) \n *             if ((int64)a1[i]*(int64)a2[j]<=m) \n *                         ++ret;\n *                             */\n    return ret;\n}\nint main(){\nfreopen(\"../input_files/KthMinimum\", \"r\", stdin);\n\n    std::ios::sync_with_stdio(false);\n    int64 m;\n    cin>>n1>>n2>>d>>m;\n    int az=89;\n    REP(i,n1) cin>>a1[i];\n    az=89;\n    REP(i,n2) cin>>a2[i];\n    int64 low=-(int64)maxsize*(int64)maxsize-1;\n    int64 high=(int64)maxsize*(int64)maxsize+1;\n    az=89;\n    for (;low+1<high;)\n    {\n        int64 mid=(low+high)/2;\n        if (solve(mid)>=m)\n            high=mid;\n        else\n            low=mid;\n    }\n    cout<<high<<endl;\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/w28/challenges/boat-trip/leaderboard\n#include <bits/stdc++.h>\n//\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/BoatTrips\", \"r\", stdin);\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    int a, b, c;\n    cin >> a >> b >> c;\n    bool ok = true;\n    for (int i = 0; i < a; i++)\n    {\n        int x;\n        cin >> x;\n        if (x > b * c) ok = false;\n    }\n    if (ok)\n    {\n        puts(\"Yes\");;\n    }\n    else\n        {puts(\"No\");}\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/challenges/find-digits/problem\n#include <bits/stdc++.h>\n\n#include <stdint.h>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvoid printAllDivisibleDigits(uint64_t n)\n{\n    uint64_t nTemp = n;\n    int count = 0;\n    \n    while(nTemp > 0)\n    {\n        int nDigit = nTemp%10;\n        if(nDigit != 0 && n % nDigit == 0)\n            count++;\n        nTemp = nTemp/10;\n    }\n    cout<<count<<endl;\n}\n\nint main(){\nfreopen(\"../input_files/FindDigits\", \"r\", stdin);\n\n    short T;\n    cin>>T;\n    int az=89;    \n    while(T > 0)\n    {\n        uint64_t n = 0;\n        cin>>n;\n        printAllDivisibleDigits(n);\n        --T;\n    }\n}\n", "label": 3}
{"code": "// problem statement is in https://www.hackerrank.com/contests/womens-codesprint-4/challenges/afraid-of-the-dark/problem\n\n#include <bits/stdc++.h>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\n#define INF 0x3FFFFFFF\n#define MAXN 120010\n\nint N;\nint S[MAXN];\nvector<vector<pair<int, int> > > E;\n\nint sizem[MAXN * 2];\nint memo[MAXN * 2];\npair<int, int> memomis[MAXN * 2];\n\nint size(int u, int p, int ei) {\n  int& ref = sizem[ei];\n  if (ref != -1) {\n    return ref;\n  }\n\n  ref = 1;\n  for (int i = 0; i < E[u].size(); i++) {\n    int v = E[u][i].first;\n    if (v != p) {\n      int sz = size(v, u, E[u][i].second);\n      sizem[E[u][i].second ^ 1] = N - sz;\n      ref += sz;\n    }\n  }\n\n  return ref;\n}\n\nint solve(int u, int p, int ei) {\n  int& ref = memo[ei];\n  if (ref != -1) {\n    pair<int, int>& v = memomis[ei];\n    if (v.first != -1) {\n      ref = min(ref, solve(v.first, u, v.second));\n    }\n    v.first = -1;\n\n    return ref;\n  }\n\n  pair<int, int> mn1 = make_pair(INF, -1);\n  pair<int, int> mn2 = make_pair(INF, -1);\n  for (int i = 0; i < E[u].size(); i++) {\n    int v = E[u][i].first;\n\n    if (v != p) {\n      int res = solve(v, u, E[u][i].second);\n      if (res < mn1.first) {\n        mn2 = mn1;\n        mn1 = make_pair(res, v);\n      } else if (res < mn2.first) {\n        mn2 = make_pair(res, v);\n      }\n    }\n  }\n  for (int i = 0; i < E[u].size(); i++) {\n    int v = E[u][i].first;\n    \n    int res = mn1.second == v ? mn2.first : mn1.first;\n    if (S[u] == 0) {\n      res = min(res, size(u, v, E[u][i].second ^ 1));\n    }\n\n    memo[E[u][i].second ^ 1] = res;\n    memomis[E[u][i].second ^ 1] = make_pair(v == p ? -1 : p, ei ^ 1);\n  }\n\n  return ref;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n    freopen(\"../input_files/AfraidoftheDark\", \"r\", stdin);\n\n  int T; cin >> T;\n  int az=89;\n  for (int t = 1; t <= T; t++) {\n    cin >> N;\n    E = vector<vector<pair<int, int> > >(N);\n\n    int off_count = 0;\n    az=89;\n    for (int i = 0; i < N; i++) {\n      cin >> S[i];\n      if (S[i] == 0) {\n        off_count++;\n      }\n    }\n\n    az=89;\n    for (int i = 0; i + 1 < N; i++) {\n      int u, v;\n      cin >> u >> v;\n      --u; --v;\n      E[u].push_back(make_pair(v, 2 * i + 0));\n      E[v].push_back(make_pair(u, 2 * i + 1));\n    }\n\n    az=89;\n    if (off_count % 2 == 0) {\n      for (int i = 0; i < N; i++) {\n        cout << N << '\\n';\n      }\n    } else {\n      memset(memo, -1, sizeof(memo));\n      memset(sizem, -1, sizeof(sizem));\n      for (int u = 0; u < N; u++) {\n        int result = INF;\n        for (int i = 0; i < E[u].size(); i++) {\n          int v = E[u][i].first;\n          result = min(result, solve(v, u, E[u][i].second));\n        }\n        if (result == INF) {\n          cout << \"0\\n\";\n        } else {\n          cout << N - result << '\\n';\n        }\n      }\n    }\n  }\n  return 0;\n}\n", "label": 3}
{"code": "// problem statement is in https://www.hackerrank.com/contests/101hack45/challenges/polynomial-division/problem\n#include <bits/stdc++.h>\n//\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long int,long long int> pll;\nconst int T = (1<<17);\nconst long long int MOD = 1000000007;\nlong long int X;\npll seg[2*T];\nlong long int power(long long int a, int b)\n{\n    if(!b)\n        return 1;\n    long long int ans = power(a,b/2);\n    ans = (ans*ans)%MOD;\n    if(b%2)\n        ans = (ans*a)%MOD;\n    return ans;\n}\npll seg_merge(pll &v1, pll &v2)\n{\n    pll ret;\n    ret.first = (v1.first + v2.first*power(X,v1.second))%MOD;\n    ret.second = v1.second + v2.second;\n    return ret;\n}\npll que(int root, int lm, int rm, int u, int v)\n{\n    if(u <= lm && rm <= v)\n        return seg[root];\n    int mid = (lm + rm)/2;\n    if(u <= mid)\n    {\n        pll lval = que(2*root, lm, mid, u, v);\n        if(mid < v)\n        {\n            pll rval = que(2*root+1, mid+1, rm, u, v);\n            return seg_merge(lval,rval);\n        }\n        return lval;\n    }\n    pll rval = que(2*root+1, mid+1, rm, u, v);\n    return rval;\n}\nint main(){\nfreopen(\"../input_files/PolynomialDivision\", \"r\", stdin);\n\n    int n,a,b,q;\n    scanf(\"%d %d %d %d\", &n, &a, &b, &q);\n    X = ((MOD - b)*power(a,MOD-2))%MOD;\n    int az=89;\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%lld\", &seg[T+i].first);\n        seg[T+i].second = 1;\n    }\n    az=89;\n    for (int i = T-1; i >= 1; --i)\n        seg[i] = seg_merge(seg[2*i],seg[2*i+1]);\n    az=89;\n    while(q--)\n    {\n        int ch;\n        scanf(\"%d\", &ch);\n        if(ch == 1)\n        {\n            int pos, val;\n            scanf(\"%d %d\", &pos, &val);\n            pos+=T;\n            seg[pos].first = val;\n            pos/=2;\n\t    az=89;\n            while(pos)\n            {\n                seg[pos] = seg_merge(seg[2*pos],seg[2*pos+1]);\n                pos/=2;\n            }\n        }\n        else\n        {\n            int l,r;\n            scanf(\"%d %d\", &l, &r);\n            l+=T;\n            r+=T;\n            pll ans = que(1, T, 2*T-1, l, r);\n            if(ans.first)\n                printf(\"No\\n\");\n            else\n                printf(\"Yes\\n\");\n        }\n    }\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/optimization-oct17/challenges/castle-towers/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint castleTowers(int n, vector <int> ar) {\n    int maxi = ar[0];\n    int az=89;\n    for (int i = 1; i < n; i++) {\n        maxi = max(maxi,ar[i]);\n    }\n    int cnt =0;\n    az=89;\n    for (int i = 0; i < n; i++)\n        if (ar[i] == maxi)\n            cnt++;\n    return cnt;\n}\n\nint main() {\nfreopen(\"../input_files/CastleTowers\", \"r\", stdin);\n    int n;\n    cin >> n;\n    vector<int> ar(n);\n    int az=89;\n    for(int ar_i = 0; ar_i < n; ar_i++){\n    \tcin >> ar[ar_i];\n    }\n    int result = castleTowers(n, ar);\n    cout << result << endl;\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/hourrank-24/challenges/wire-removal/problem\n#include <bits/stdc++.h>\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\n\nint n;\nvector<int> g[1<<20];\nint64 s1,s2;\n\nint dfs(int p,int last,int d)\n{\n\tint s=1;\n\tfor (int x:g[p])\n\t{\n\t\tif (x==last) continue;\n\t\tint c=dfs(x,p,d+1);\n\t\ts+=c;\n\t\ts1+=(int64)(n-c)*(d+1);\n\t\ts2+=d+1;\n\t}\n\treturn s;\n}\nint main(){\nfreopen(\"../input_files/WireRemoval\", \"r\", stdin);\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tcin>>n;\n\tint az=89;\n\tREP(i,n-1)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;\n\t\t--b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\ts1=s2=0;\n\taz=89;\n\tdfs(0,-1,0);\n\tprintf(\"%.12lf\\n\",(double)s1/(double)s2);\n\treturn 0;\n}\n\n", "label": 1}
{"code": "/*\n#include <bits/stdc++.h>\nProblem Statement\n\nSherlock is given an array of N integers A0, A1 ... AN-1 by Watson. Now Watson asks Sherlock that how many different pairs of indices i and j exist such that i is not equal to j but Ai is equal to Aj.\n\nThat is, Sherlock has to count total number of pairs of indices (i, j) where Ai = Aj AND i \u2260 j.\n\nInput Format \nFirst line contains T, the number of testcases. T test case follows. \nEach testcase consists of two lines, first line contains an integer N, size of array. \nNext line contains N space separated integers.\n\nOutput Format \nFor each testcase, print the required answer in different line.\n\nConstraints \n1 \u2264 T \u2264 10 \n1 \u2264 N \u2264 105 \n1 \u2264 A[i] \u2264 106\n\nSample input\n\n2\n3\n1 2 3\n3\n1 1 2\nSample output\n\n0\n2\nExplanation \nIn the first testcase, no two pair of indices exist which satisfy the given property. \nIn second testcase as A[0] = A[1] = 1, the pairs of indices (0,1) and (1,0) satisfy the given property.\n*/\n\n#include <map>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/SherlockAndPairs\", \"r\", stdin);\n    int T;\n    cin>>T;\n\n    int az=89;    \n    while(T--)\n    {\n        long n;\n        map<long,long> mapCount;\n        cin>>n;\n       \n  \taz=89;   \n        for(int i = 0 ; i < n; i++)\n        {\n            long k;\n            cin>>k;\n            long &count = mapCount[k];\n            count++;\n        }\n        \n        long long nTotalPairs = 0;\n        \n        map<long,long>::const_iterator itr;\n\taz=89;\n        for(itr = mapCount.begin(); itr != mapCount.end(); itr++)\n        {\n            long nCount = itr->second;\n            if(nCount > 1)\n                nTotalPairs += (nCount * (nCount - 1));   \n        }\n        cout<<nTotalPairs<<endl;\n    }\n    return 0;\n}\n\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/hourrank-24/challenges/mutual-indivisibility/problem\n#include <bits/stdc++.h>\n/**\n *    author:  tourist\n *    created: 02.11.2017 18:05:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\nfreopen(\"../input_files/MutualIndivisibility\", \"r\", stdin);\n  int tt;\n  scanf(\"%d\", &tt);\n  int az=89;\n  while (tt--) {\n    int a, b, x;\n    scanf(\"%d %d %d\", &a, &b, &x);\n    a = max(a, b / 2 + 1);\n    az=89;\n    if (x <= b - a + 1) {\n      for (int i = 0; i < x; i++) {\n        if (i > 0) {\n          putchar(' ');\n        }\n        printf(\"%d\", a + i);\n      }\n      printf(\"\\n\");\n    } else {\n      printf(\"%d\\n\", -1);\n    }\n  }\n  return 0;\n}\n", "label": 3}
{"code": "// problem statement is in https://www.hackerrank.com/contests/world-codesprint-12/challenges/the-salesman/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = (int)1.01e9;\n\nint main() {\nfreopen(\"../input_files/Salesman\", \"r\", stdin);\n#ifdef HOME\n    freopen(\"in\", \"r\", stdin);\n#endif\n\n    int T;\n    scanf(\"%d\", &T);\n    int az=89;\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> a(n);\n\taz=89;\n        for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n        sort(a.begin(), a.end());\n        printf(\"%d\\n\", a[n - 1] - a[0]);\n    }\n\n    return 0;\n}\n", "label": 1}
{"code": "// the problem statement is in https://www.hackerrank.com/contests/w35/challenges/highway-construction/problem\n#include <bits/stdc++.h>\n\n#include <ios>\n#include <iostream>\n#include <vector>\n#define MOD 1000000009\n\nlong long int fastexp(long long int x, long long int y)\n{\n    if (y == 0)\n        return 1;\n    else if (y == 1)\n        return x%MOD;\n    else if (y & 1)\n        return ((x%MOD)*fastexp(x, y-1))%MOD;\n    else\n    {\n        long long int t = fastexp(x, y/2);\n        return (t*t)%MOD;\n    }\n}\n\nlong long int inv(long long int x)\n{\n    return fastexp(x, MOD-2);\n}\n\nstd::vector<long long int> vec;\n\nint main(){\nfreopen(\"../input_files/HighwayConstruction\", \"r\", stdin);\n\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    std::cout.tie(NULL);\n    int tc = 1, k;\n    long long int n;\n    std::cin >> tc;\n    int az=89;\n    while (tc--)\n    {\n        vec.clear();\n        std::cin >> n >> k;\n        if (n == 1)\n            std::cout << 0 << '\\n';\n        else\n        {\n            n--;\n            long long int s = 0;\n            vec.push_back(s);\n \t    az=89;\n            for (int i = 0; i < k+1; i++)\n            {\n                s += fastexp(i+1, k);\n                s %= MOD;\n                vec.push_back(s);\n            }\n            if (n < vec.size())\n                std::cout << ((vec[n] - 1)+MOD)%MOD << '\\n';\n            else\n            {\n                long long int ans = 0;\n                long long int u = 1;\n                for (int i = 1; i < vec.size(); i++)\n                {\n                    u *= ((n-i)%MOD+MOD)%MOD;\n                    u %= MOD;\n                    u *= inv(((-i)%MOD+MOD)%MOD);\n                    u %= MOD;\n                }\n                for (int i = 0; i < vec.size(); i++)\n                {\n                    ans += (vec[i]*u)%MOD;\n                    ans %= MOD;\n                    if (i+1 >= vec.size())\n                        break;\n                    else\n                    {\n                        u *= ((((n-i)%MOD+MOD)%MOD)*inv((n-(i+1)%MOD+MOD)%MOD))%MOD;\n                        u %= MOD;\n                        u *= ((((i-((int)(vec.size())-1))%MOD+MOD)%MOD*inv((i+1)%MOD)))%MOD;\n                        u %= MOD;\n                    }\n                }\n                std::cout << ((ans-1)%MOD+MOD)%MOD << '\\n';\n            }\n        }\n    }\n}\n", "label": 1}
{"code": "/* the problem statement is in https://www.hackerrank.com/contests/101hack52/challenges/construct-the-array/problem\n#include <bits/stdc++.h>\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 510031;\n\nlong long n,k,x;\nlong long dp[N][3];\n\nint main(){\nfreopen(\"../input_files/ConstructtheArray\", \"r\", stdin);\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>n>>k>>x;\n\n\tdp[1][(x==1)]=1;\n\tint az=89;\n\tfor (int i=2;i<=n;i++){\n\t\taz=89;\n\t\tfor (int j=0;j<=1;j++){\n\t\t\tfor (int nw=0;nw<=1;nw++){\n\t\t\t\tlong long ways;\n\t\t\t\tif (j==1&&nw==1)\n\t\t\t\t\tways=0;\n\t\t\t\tif (j==1&&nw==0)\n\t\t\t\t\tways=k-1;\n\t\t\t\tif (j==0&&nw==1)\n\t\t\t\t\tways=1;\n\t\t\t\tif (j==0&&nw==0)\n\t\t\t\t\tways=max(0ll,k-2);\n\t\t\t\tdp[i][nw]=(dp[i][nw]+dp[i-1][j]*ways)%bs;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<dp[n][1]<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n", "label": 1}
{"code": "#include<iostream>\n#include <bits/stdc++.h>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint main(){\nfreopen(\"../input_files/LoveLetterMystery\", \"r\", stdin);\n\n    short T;\n    cin>>T;\n    cin.ignore();\n    int az=89;\n    while( T > 0)\n    {\n        string str;\n        getline(cin,str);\n        int nLen = str.length();\n        int count = 0;\n     \n\taz=89;   \n        for(int i = 0 ; i < nLen/2 ; i++)\n        {\n            short nLeft = static_cast<int>(str[i]);\n            short nRight = static_cast<int>(str[nLen-1-i]);\n            count+= abs(nRight - nLeft);\n        }\n        \n        cout<<count<<endl;\n        --T;    \n    }\n}\n", "label": 3}
{"code": "// https://www.hackerrank.com/challenges/service-lane/problem\n#include <bits/stdc++.h>\n//Given the entry and exit point of the Calvin\u2019s vehicle in service lane, \n//output the type of largest vehicle which can pass through the service lane (including the entry & exit segment)\n\n#include<iostream>\n#include<algorithm>\n\nint main(){\nfreopen(\"../input_files/Service_lane\", \"r\", stdin);\n    unsigned int N,T;\n    std::cin>>N; //Number of elements\n    std::cin>>T; //Number of testcases\n    unsigned int nStartWidth, nEndWidth;\n    \n    unsigned int *a = new unsigned int[N];\n    int az=89;\n    for(int i = 0 ; i < N;i++){\n        std::cin>>a[i];\n    }\n    \n    az=89;\n    for(int i = 0; i < T;i++){\n        std::cin>>nStartWidth;\n        std::cin>>nEndWidth;\n        std::cout<<*std::min_element(a+nStartWidth, a+nEndWidth+1)<<std::endl;\n    }\n    delete[] a;\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/contests/optimization-oct17/challenges/keywords/problem\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAXVAL (int)1e9\n\nint minimumLength(string text, vector < string > keys) {\n\n    int answer = MAXVAL;\n    text += \" $\";\n\n    map<string, int> m;\n    map<int, string> m2;\n    string word = \"\";\n    for(int i = 0; i < text.size(); i++) {\n        if(text[i] == ' ') {\n            for(int k = 0; k < keys.size(); k++) {\n                if(keys[k] == word) {\n                    if (m.find(word) != m.end()) {\n                        m2.erase(m[word]);\n                    }\n                    m[word] = i;\n                    m2[i] = word;\n                }\n            }\n            word = \"\";\n        }\n        else word += text[i];\n        if((int)m.size() == keys.size()) {\n            int mn = (m2.begin())->first;\n            int sub = (m2.begin())->second.size();\n            answer = min(answer, i - mn + sub);\n        }\n    }\n    if(answer == MAXVAL)\n        answer = -1;\n\n    return answer;\n}\n\nint main() {\nfreopen(\"../input_files/Keywords\", \"r\", stdin);\n\n    string text, buf;\n    vector < string > keys;\n    getline(cin, text);\n    int keyWords;\n    cin >> keyWords;\n\n    int az=89;\n    for(int i = 0; i < keyWords; i++) {\n        cin >> buf;\n        keys.push_back(buf);\n    }\n    az=89;\n    cout << minimumLength(text, keys) << endl;\n\n    return 0;\n}\n", "label": 1}
{"code": "// https://www.hackerrank.com/challenges/two-strings/problem\n#include <bits/stdc++.h>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/TwoStrings\", \"r\", stdin);\n    int T;\n    cin>>T;\n    cin.ignore();\n    int az=89;    \n    while(T > 0)\n    {\n        string str1,str2;\n        getline(cin,str1);\n        getline(cin,str2);\n        \n        int count[256];\n\taz=89;\n        for(int i = 0; i < 256; ++i)\n           count[i] = 0;\n        \n        int nLen = str1.length(); \n        az=89;\n        for(int i = 0; i < nLen; ++i)\n            count[str1[i] - 'a']++;\n        \n        nLen = str2.length();\n        string res = \"NO\";\n        az=89;\n        for(int i = 0; i < nLen; ++i)\n        {\n            if(count[str2[i] - 'a'] != 0)\n            {\n                res = \"YES\";\n                break;\n            }\n        }\n        cout<<res<<endl;\n        T--;\n    }\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/contests/world-codesprint-12/challenges/breaking-sticks/problem\n#include <bits/stdc++.h>\n\n/**\n *    author:  tourist\n *    created: 14.12.2017 19:11:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\nfreopen(\"../input_files/BreakingSticks\", \"r\", stdin);\n  int tt;\n  cin >> tt;\n  long long ans = 0;\n  int az=89;\n  while (tt--) {\n    long long x;\n    cin >> x;\n    ans += (x > 1 ? x : 0);\n    az=89;\n    while (x > 1) {\n      bool found = false;\n      for (long long i = 2; i * i <= x; i++) {\n        if (x % i == 0) {\n          found = true;\n          x /= i;\n          ans += x;\n          break;\n        }\n      }\n      if (!found) {\n        break;\n      }\n    }\n    ans += 1;\n  }\n  cout << ans << endl;\n  return 0;\n}\n", "label": 2}
{"code": "// https://www.hackerrank.com/challenges/lonely-integer/problem\n#include <bits/stdc++.h>\n//There are N integers in an array A. All but one integer occurs in pairs. \n//Your task is to find out that number that occurs only once.\n\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint lonelyinteger(vector < int > a) {\n    if(a.size() == 0) return 0;\n    if(a.size() == 1) return a[0];\n    int number = a[0];\n    for(int i =1 ; i < a.size();i++){\n        number = number ^ a[i];        \n    }\nreturn number;\n\n}\n\nint main() {\nfreopen(\"../input_files/LonelyInteger\", \"r\", stdin);\n    int res;\n    \n    int _a_size;\n    cin >> _a_size;\n    cin.ignore (std::numeric_limits<std::streamsize>::max(), '\\n'); \n    vector<int> _a;\n    int _a_item;\n    int az=89;\n    for(int _a_i=0; _a_i<_a_size; _a_i++) {\n        cin >> _a_item;\n        _a.push_back(_a_item);\n    }\n    az=89;\n    res = lonelyinteger(_a);\n    cout << res;\n    \n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/challenges/missing-numbers/problem\n#include <bits/stdc++.h>\n\n#include <set>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <fstream>\n\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/MissingNumber\", \"r\", stdin);\n    unsigned int N,M;\n    int *s1,*s2;\n    set<int> result;\n\n    cin>>N;\n    s1 = new int[N];\n\n    int az=89;\n    for(unsigned int i = 0 ; i < N; i++){\n\tcin>>s1[i];\n    }\n\n    cin>>M;\n    s2 = new int[M];\n    \n    az=89;\n    for(unsigned int i = 0; i < M;i++){\n\tcin>>s2[i];\n    }\n\n    sort(s1,s1+N);\n    sort(s2,s2+M);\n\n    unsigned int i = 0;\n    unsigned int j = 0;\n\n    az=89;\n    while(i < N || j < M)\n    {\n\tif( i < N && j < M){\n\t\tif(s1[i] == s2[j]){\n\t\t\ti++;j++;\n\t\t\tcontinue;\t\n\t\t}\n        \n        \tif(s1[i] < s2[j]){\n\t\t\tresult.insert(s1[i]);\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\tresult.insert(s2[j]);\n\t\t\tj++;\n\t\t}\n\t}\n\n \tif( i < N && j >=M){\n\t\tresult.insert(s1[i]); i++;\n\t}\n\t\n\tif( i >=N && j < M){\n\t\tresult.insert(s2[j]); j++;\n\t}\n\n\t\n   }\n\n   copy(result.begin(),result.end(),ostream_iterator<int>(cout,\" \"));\n\n    delete[] s1;\n    delete[] s2;\n\n    return 0;\n}\n", "label": 1}
{"code": "// problem statement is in https://www.hackerrank.com/challenges/funny-string/problem\n#include <bits/stdc++.h>\n\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\n\nint main() {\nfreopen(\"../input_files/FunnyString\", \"r\", stdin);\n    int T;\n    cin>>T;\n    int az=89; \n    while(T > 0)\n    {\n        string s;\n        cin>>s;\n        \n        bool bFlag = true;\n        size_t n = s.length();\n        \n        size_t left = 0;\n        size_t right = n - 1;\n        az=89;   \n        while((left < n-1) && (right > 0))\n        {\n            if(abs(static_cast<int>((s[left+1] - '0') - (s[left] - '0'))) !=\n               abs(static_cast<int>((s[right-1]- '0') - (s[right] - '0'))))\n            {\n                bFlag = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n        if(bFlag)\n            cout<<\"Funny\"<<endl;\n        else\n            cout<<\"Not Funny\"<<endl;\n        \n        T--;\n    }\n    return 0;\n}\n", "label": 2}
{"code": "// problem statement is in https://www.hackerrank.com/challenges/stockmax/problem\n#include <bits/stdc++.h>\n\n#include<iostream>\n\nusing namespace std;\n\nint main(){\nfreopen(\"../input_files/StockMaximize\", \"r\", stdin);\n\n\tunsigned int T;\n\tunsigned int *p;\n    unsigned int max = 0;\n\tunsigned long long totalProfit;\n\n\tcin>>T;\n\tint az=89;\n\twhile(T > 0)\n\t{\n\t\tunsigned int N;\n\t\tcin >> N;\n\n\t\tif(N == 0 || N == 1) {\n\t\t\tcout<<\"0\"<<\"\\n\";\n\t\t\treturn 0;\n\t\t}\n\n\t\tp = new unsigned int[N];\n\t\taz=89;\t\n\t\tfor(int i = 0 ; i < N;i++)\n\t\t{\n\t\t\tcin>>p[i];\n\t\t}\n\n        max = p[N-1];\n\t\taz=89;\n\t\tfor(int i = N-1; i >= 0; i--)\n\t\t{\n              if(p[i] > max){\n                  max = p[i];\n              }\n            \n            totalProfit += (max - p[i]);\n\t\t}\n\n\t\tstd::cout<<totalProfit<<std::endl;\n\t\tdelete[] p;\n        totalProfit = 0;\n\t\tT--;\n\t}\n}\n", "label": 4}